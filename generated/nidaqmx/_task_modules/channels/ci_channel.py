# Do not edit this file; it was automatically generated.

import ctypes
import numpy

from nidaqmx._lib import lib_importer, ctypes_byte_str, c_bool32
from nidaqmx.scale import Scale
from nidaqmx.errors import (
    check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
from nidaqmx._task_modules.channels.channel import Channel
from nidaqmx.constants import (
    AngleUnits, AngularVelocityUnits, CountDirection, CounterFrequencyMethod,
    DataTransferActiveTransferMode, DigitalWidthUnits, Edge, EncoderType,
    EncoderZIndexPhase, FilterResponse, FrequencyUnits, GpsSignalType,
    InputDataTransferCondition, LengthUnits, Level, LogicLvlBehavior,
    SampClkOverrunBehavior, TerminalConfiguration, TimeUnits, UsageTypeCI,
    VelocityUnits)


class CIChannel(Channel):
    """
    Represents one or more counter input virtual channels and their properties.
    """
    __slots__ = []

    def __repr__(self):
        return f'CIChannel(name={self._name})'

    @property
    def ci_ang_encoder_initial_angle(self):
        """
        float: Specifies the starting angle of the encoder. This value
            is in the units you specify with **ci_ang_encoder_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 2177)
        return val

    @ci_ang_encoder_initial_angle.setter
    def ci_ang_encoder_initial_angle(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 2177, val)

    @ci_ang_encoder_initial_angle.deleter
    def ci_ang_encoder_initial_angle(self):
        cfunc = lib_importer.windll.DAQmxResetCIAngEncoderInitialAngle
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_ang_encoder_pulses_per_rev(self):
        """
        int: Specifies the number of pulses the encoder generates per
            revolution. This value is the number of pulses on either
            signal A or signal B, not the total number of pulses on both
            signal A and signal B.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 2165)
        return val

    @ci_ang_encoder_pulses_per_rev.setter
    def ci_ang_encoder_pulses_per_rev(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 2165, val)

    @ci_ang_encoder_pulses_per_rev.deleter
    def ci_ang_encoder_pulses_per_rev(self):
        cfunc = lib_importer.windll.DAQmxResetCIAngEncoderPulsesPerRev
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_ang_encoder_units(self):
        """
        :class:`nidaqmx.constants.AngleUnits`: Specifies the units to
            use to return angular position measurements from the
            channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6310)
        return AngleUnits(val)

    @ci_ang_encoder_units.setter
    def ci_ang_encoder_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6310, val)

    @ci_ang_encoder_units.deleter
    def ci_ang_encoder_units(self):
        cfunc = lib_importer.windll.DAQmxResetCIAngEncoderUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count(self):
        """
        int: Indicates the current value of the count register.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 328)
        return val

    @property
    def ci_count_edges_active_edge(self):
        """
        :class:`nidaqmx.constants.Edge`: Specifies on which edges to
            increment or decrement the counter.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 1687)
        return Edge(val)

    @ci_count_edges_active_edge.setter
    def ci_count_edges_active_edge(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 1687, val)

    @ci_count_edges_active_edge.deleter
    def ci_count_edges_active_edge(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesActiveEdge
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_dir_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8689)
        return val

    @ci_count_edges_count_dir_dig_fltr_enable.setter
    def ci_count_edges_count_dir_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8689, val)

    @ci_count_edges_count_dir_dig_fltr_enable.deleter
    def ci_count_edges_count_dir_dig_fltr_enable(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountDirDigFltrEnable)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_dir_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8690)
        return val

    @ci_count_edges_count_dir_dig_fltr_min_pulse_width.setter
    def ci_count_edges_count_dir_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8690, val)

    @ci_count_edges_count_dir_dig_fltr_min_pulse_width.deleter
    def ci_count_edges_count_dir_dig_fltr_min_pulse_width(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountDirDigFltrMinPulseWidth)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_dir_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8692)
        return val

    @ci_count_edges_count_dir_dig_fltr_timebase_rate.setter
    def ci_count_edges_count_dir_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8692, val)

    @ci_count_edges_count_dir_dig_fltr_timebase_rate.deleter
    def ci_count_edges_count_dir_dig_fltr_timebase_rate(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountDirDigFltrTimebaseRate)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_dir_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8691)
        return val

    @ci_count_edges_count_dir_dig_fltr_timebase_src.setter
    def ci_count_edges_count_dir_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8691, val)

    @ci_count_edges_count_dir_dig_fltr_timebase_src.deleter
    def ci_count_edges_count_dir_dig_fltr_timebase_src(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountDirDigFltrTimebaseSrc)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_dir_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8693)
        return val

    @ci_count_edges_count_dir_dig_sync_enable.setter
    def ci_count_edges_count_dir_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8693, val)

    @ci_count_edges_count_dir_dig_sync_enable.deleter
    def ci_count_edges_count_dir_dig_sync_enable(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountDirDigSyncEnable)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_dir_hyst(self):
        """
        float: Specifies a hysteresis level applied to the
            **ci_count_edges_count_dir_thresh_voltage**. The source
            signal must fall below
            **ci_count_edges_count_dir_thresh_voltage** minus the
            hysteresis before a change in count direction occurs.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12722)
        return val

    @ci_count_edges_count_dir_hyst.setter
    def ci_count_edges_count_dir_hyst(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12722, val)

    @ci_count_edges_count_dir_hyst.deleter
    def ci_count_edges_count_dir_hyst(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesCountDirHyst
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_dir_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the count reset line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12446)
        return LogicLvlBehavior(val)

    @ci_count_edges_count_dir_logic_lvl_behavior.setter
    def ci_count_edges_count_dir_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12446, val)

    @ci_count_edges_count_dir_logic_lvl_behavior.deleter
    def ci_count_edges_count_dir_logic_lvl_behavior(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountDirLogicLvlBehavior)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_dir_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12445)
        return TerminalConfiguration(val)

    @ci_count_edges_count_dir_term_cfg.setter
    def ci_count_edges_count_dir_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12445, val)

    @ci_count_edges_count_dir_term_cfg.deleter
    def ci_count_edges_count_dir_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesCountDirTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_dir_thresh_voltage(self):
        """
        float: Specifies the voltage level applied to the Count
            Direction terminal. When the signal is above this threshold,
            the counter counts up. When the signal is below this
            threshold, the counter counts down.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12721)
        return val

    @ci_count_edges_count_dir_thresh_voltage.setter
    def ci_count_edges_count_dir_thresh_voltage(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12721, val)

    @ci_count_edges_count_dir_thresh_voltage.deleter
    def ci_count_edges_count_dir_thresh_voltage(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountDirThreshVoltage)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_reset_active_edge(self):
        """
        :class:`nidaqmx.constants.Edge`: Specifies on which edge of the
            signal to reset the count.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12210)
        return Edge(val)

    @ci_count_edges_count_reset_active_edge.setter
    def ci_count_edges_count_reset_active_edge(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12210, val)

    @ci_count_edges_count_reset_active_edge.deleter
    def ci_count_edges_count_reset_active_edge(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesCountResetActiveEdge
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_reset_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12211)
        return val

    @ci_count_edges_count_reset_dig_fltr_enable.setter
    def ci_count_edges_count_reset_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12211, val)

    @ci_count_edges_count_reset_dig_fltr_enable.deleter
    def ci_count_edges_count_reset_dig_fltr_enable(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountResetDigFltrEnable)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_reset_dig_fltr_min_pulse_width(self):
        """
        float: Specifies the minimum pulse width the filter recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12212)
        return val

    @ci_count_edges_count_reset_dig_fltr_min_pulse_width.setter
    def ci_count_edges_count_reset_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12212, val)

    @ci_count_edges_count_reset_dig_fltr_min_pulse_width.deleter
    def ci_count_edges_count_reset_dig_fltr_min_pulse_width(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountResetDigFltrMinPulseWidth)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_reset_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12214)
        return val

    @ci_count_edges_count_reset_dig_fltr_timebase_rate.setter
    def ci_count_edges_count_reset_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12214, val)

    @ci_count_edges_count_reset_dig_fltr_timebase_rate.deleter
    def ci_count_edges_count_reset_dig_fltr_timebase_rate(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountResetDigFltrTimebaseRate)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_reset_dig_fltr_timebase_src(self):
        """
        str: Specifies the input of the signal to use as the timebase of
            the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12213)
        return val

    @ci_count_edges_count_reset_dig_fltr_timebase_src.setter
    def ci_count_edges_count_reset_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12213, val)

    @ci_count_edges_count_reset_dig_fltr_timebase_src.deleter
    def ci_count_edges_count_reset_dig_fltr_timebase_src(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountResetDigFltrTimebaseSrc)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_reset_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12215)
        return val

    @ci_count_edges_count_reset_dig_sync_enable.setter
    def ci_count_edges_count_reset_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12215, val)

    @ci_count_edges_count_reset_dig_sync_enable.deleter
    def ci_count_edges_count_reset_dig_sync_enable(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountResetDigSyncEnable)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_reset_enable(self):
        """
        bool: Specifies whether to reset the count on the active edge
            specified with **ci_count_edges_count_reset_term**.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12207)
        return val

    @ci_count_edges_count_reset_enable.setter
    def ci_count_edges_count_reset_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12207, val)

    @ci_count_edges_count_reset_enable.deleter
    def ci_count_edges_count_reset_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesCountResetEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_reset_hyst(self):
        """
        float: Specifies a hysteresis level applied to
            **ci_count_edges_count_reset_thresh_voltage**. When
            **ci_count_edges_count_reset_active_edge** is rising, the
            source signal must first fall below
            **ci_count_edges_count_reset_thresh_voltage** minus the
            hysteresis before a rising edge is detected at
            **ci_count_edges_count_reset_thresh_voltage**. When
            **ci_count_edges_count_reset_active_edge** is falling, the
            source signal must first rise above
            **ci_count_edges_count_reset_thresh_voltage** plus the
            hysteresis before a falling edge is detected at
            **ci_count_edges_count_reset_thresh_voltage**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12724)
        return val

    @ci_count_edges_count_reset_hyst.setter
    def ci_count_edges_count_reset_hyst(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12724, val)

    @ci_count_edges_count_reset_hyst.deleter
    def ci_count_edges_count_reset_hyst(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesCountResetHyst
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_reset_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the count reset line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12448)
        return LogicLvlBehavior(val)

    @ci_count_edges_count_reset_logic_lvl_behavior.setter
    def ci_count_edges_count_reset_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12448, val)

    @ci_count_edges_count_reset_logic_lvl_behavior.deleter
    def ci_count_edges_count_reset_logic_lvl_behavior(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountResetLogicLvlBehavior)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_reset_reset_cnt(self):
        """
        int: Specifies the value to reset the count to.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 12208)
        return val

    @ci_count_edges_count_reset_reset_cnt.setter
    def ci_count_edges_count_reset_reset_cnt(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 12208, val)

    @ci_count_edges_count_reset_reset_cnt.deleter
    def ci_count_edges_count_reset_reset_cnt(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesCountResetResetCount
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_reset_term(self):
        """
        str: Specifies the input terminal of the signal to reset the
            count.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12209)
        return val

    @ci_count_edges_count_reset_term.setter
    def ci_count_edges_count_reset_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12209, val)

    @ci_count_edges_count_reset_term.deleter
    def ci_count_edges_count_reset_term(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesCountResetTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_reset_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12447)
        return TerminalConfiguration(val)

    @ci_count_edges_count_reset_term_cfg.setter
    def ci_count_edges_count_reset_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12447, val)

    @ci_count_edges_count_reset_term_cfg.deleter
    def ci_count_edges_count_reset_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesCountResetTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_count_reset_thresh_voltage(self):
        """
        float: Specifies the voltage level at which to recognize the
            counter reset event.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12723)
        return val

    @ci_count_edges_count_reset_thresh_voltage.setter
    def ci_count_edges_count_reset_thresh_voltage(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12723, val)

    @ci_count_edges_count_reset_thresh_voltage.deleter
    def ci_count_edges_count_reset_thresh_voltage(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesCountResetThreshVoltage)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8694)
        return val

    @ci_count_edges_dig_fltr_enable.setter
    def ci_count_edges_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8694, val)

    @ci_count_edges_dig_fltr_enable.deleter
    def ci_count_edges_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8695)
        return val

    @ci_count_edges_dig_fltr_min_pulse_width.setter
    def ci_count_edges_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8695, val)

    @ci_count_edges_dig_fltr_min_pulse_width.deleter
    def ci_count_edges_dig_fltr_min_pulse_width(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesDigFltrMinPulseWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8697)
        return val

    @ci_count_edges_dig_fltr_timebase_rate.setter
    def ci_count_edges_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8697, val)

    @ci_count_edges_dig_fltr_timebase_rate.deleter
    def ci_count_edges_dig_fltr_timebase_rate(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesDigFltrTimebaseRate
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8696)
        return val

    @ci_count_edges_dig_fltr_timebase_src.setter
    def ci_count_edges_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8696, val)

    @ci_count_edges_dig_fltr_timebase_src.deleter
    def ci_count_edges_dig_fltr_timebase_src(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesDigFltrTimebaseSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8698)
        return val

    @ci_count_edges_dig_sync_enable.setter
    def ci_count_edges_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8698, val)

    @ci_count_edges_dig_sync_enable.deleter
    def ci_count_edges_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_dir(self):
        """
        :class:`nidaqmx.constants.CountDirection`: Specifies whether to
            increment or decrement the counter on each edge.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 1686)
        return CountDirection(val)

    @ci_count_edges_dir.setter
    def ci_count_edges_dir(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 1686, val)

    @ci_count_edges_dir.deleter
    def ci_count_edges_dir(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesDir
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_dir_term(self):
        """
        str: Specifies the source terminal of the digital signal that
            controls the count direction if **ci_count_edges_dir** is
            **CountDirection1.EXTERNAL_SOURCE**.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8673)
        return val

    @ci_count_edges_dir_term.setter
    def ci_count_edges_dir_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8673, val)

    @ci_count_edges_dir_term.deleter
    def ci_count_edges_dir_term(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesDirTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_gate_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            gate input signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12529)
        return val

    @ci_count_edges_gate_dig_fltr_enable.setter
    def ci_count_edges_gate_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12529, val)

    @ci_count_edges_gate_dig_fltr_enable.deleter
    def ci_count_edges_gate_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesGateDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_gate_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the digital
            filter recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12530)
        return val

    @ci_count_edges_gate_dig_fltr_min_pulse_width.setter
    def ci_count_edges_gate_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12530, val)

    @ci_count_edges_gate_dig_fltr_min_pulse_width.deleter
    def ci_count_edges_gate_dig_fltr_min_pulse_width(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesGateDigFltrMinPulseWidth)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_gate_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12532)
        return val

    @ci_count_edges_gate_dig_fltr_timebase_rate.setter
    def ci_count_edges_gate_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12532, val)

    @ci_count_edges_gate_dig_fltr_timebase_rate.deleter
    def ci_count_edges_gate_dig_fltr_timebase_rate(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesGateDigFltrTimebaseRate)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_gate_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12531)
        return val

    @ci_count_edges_gate_dig_fltr_timebase_src.setter
    def ci_count_edges_gate_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12531, val)

    @ci_count_edges_gate_dig_fltr_timebase_src.deleter
    def ci_count_edges_gate_dig_fltr_timebase_src(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICountEdgesGateDigFltrTimebaseSrc)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_gate_enable(self):
        """
        bool: Specifies whether to enable the functionality to gate the
            counter input signal for a count edges measurement.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12525)
        return val

    @ci_count_edges_gate_enable.setter
    def ci_count_edges_gate_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12525, val)

    @ci_count_edges_gate_enable.deleter
    def ci_count_edges_gate_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesGateEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_gate_hyst(self):
        """
        float: Specifies a hysteresis level applied to the
            **ci_count_edges_gate_thresh_voltage**. When
            **ci_count_edges_gate_when** is High, the source signal must
            fall below **ci_count_edges_gate_thresh_voltage** minus the
            hysteresis before the counter resumes counting. When
            **ci_count_edges_gate_when** is Low, the source signal must
            rise above **ci_count_edges_gate_thresh_voltage** plus the
            hysteresis before the counter resumes counting.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12726)
        return val

    @ci_count_edges_gate_hyst.setter
    def ci_count_edges_gate_hyst(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12726, val)

    @ci_count_edges_gate_hyst.deleter
    def ci_count_edges_gate_hyst(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesGateHyst
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_gate_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the gate input line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12528)
        return LogicLvlBehavior(val)

    @ci_count_edges_gate_logic_lvl_behavior.setter
    def ci_count_edges_gate_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12528, val)

    @ci_count_edges_gate_logic_lvl_behavior.deleter
    def ci_count_edges_gate_logic_lvl_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesGateLogicLvlBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_gate_term(self):
        """
        str: Specifies the gate terminal.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12526)
        return val

    @ci_count_edges_gate_term.setter
    def ci_count_edges_gate_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12526, val)

    @ci_count_edges_gate_term.deleter
    def ci_count_edges_gate_term(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesGateTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_gate_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            gate terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12527)
        return TerminalConfiguration(val)

    @ci_count_edges_gate_term_cfg.setter
    def ci_count_edges_gate_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12527, val)

    @ci_count_edges_gate_term_cfg.deleter
    def ci_count_edges_gate_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesGateTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_gate_thresh_voltage(self):
        """
        float: Specifies the voltage level at which to recognize the
            counter gate signal.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12725)
        return val

    @ci_count_edges_gate_thresh_voltage.setter
    def ci_count_edges_gate_thresh_voltage(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12725, val)

    @ci_count_edges_gate_thresh_voltage.deleter
    def ci_count_edges_gate_thresh_voltage(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesGateThreshVoltage
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_gate_when(self):
        """
        :class:`nidaqmx.constants.Level`: Specifies whether the counter
            gates input pulses while the signal is high or low.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12533)
        return Level(val)

    @ci_count_edges_gate_when.setter
    def ci_count_edges_gate_when(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12533, val)

    @ci_count_edges_gate_when.deleter
    def ci_count_edges_gate_when(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesGateWhen
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_hyst(self):
        """
        float: Specifies a hysteresis level to apply to
            **ci_count_edges_thresh_voltage**. When
            **ci_count_edges_active_edge** is rising, the source signal
            must first fall below **ci_count_edges_thresh_voltage**
            minus the hysteresis before a rising edge is detected at
            **ci_count_edges_thresh_voltage**. When
            **ci_count_edges_active_edge** is falling, the source signal
            must first rise above **ci_count_edges_thresh_voltage** plus
            the hysteresis before a falling edge is detected at
            **ci_count_edges_thresh_voltage**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12720)
        return val

    @ci_count_edges_hyst.setter
    def ci_count_edges_hyst(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12720, val)

    @ci_count_edges_hyst.deleter
    def ci_count_edges_hyst(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesHyst
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_initial_cnt(self):
        """
        int: Specifies the starting value from which to count.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 1688)
        return val

    @ci_count_edges_initial_cnt.setter
    def ci_count_edges_initial_cnt(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 1688, val)

    @ci_count_edges_initial_cnt.deleter
    def ci_count_edges_initial_cnt(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesInitialCnt
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the input line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12444)
        return LogicLvlBehavior(val)

    @ci_count_edges_logic_lvl_behavior.setter
    def ci_count_edges_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12444, val)

    @ci_count_edges_logic_lvl_behavior.deleter
    def ci_count_edges_logic_lvl_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesLogicLvlBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_term(self):
        """
        str: Specifies the input terminal of the signal to measure.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 6343)
        return val

    @ci_count_edges_term.setter
    def ci_count_edges_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 6343, val)

    @ci_count_edges_term.deleter
    def ci_count_edges_term(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12443)
        return TerminalConfiguration(val)

    @ci_count_edges_term_cfg.setter
    def ci_count_edges_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12443, val)

    @ci_count_edges_term_cfg.deleter
    def ci_count_edges_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_count_edges_thresh_voltage(self):
        """
        float: Specifies the voltage level at which to recognize
            waveform repetitions. Select a voltage level that occurs
            only once within the entire period of a waveform. You also
            can select a voltage that occurs only once while the voltage
            rises or falls.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12719)
        return val

    @ci_count_edges_thresh_voltage.setter
    def ci_count_edges_thresh_voltage(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12719, val)

    @ci_count_edges_thresh_voltage.deleter
    def ci_count_edges_thresh_voltage(self):
        cfunc = lib_importer.windll.DAQmxResetCICountEdgesThreshVoltage
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_ctr_timebase_active_edge(self):
        """
        :class:`nidaqmx.constants.Edge`: Specifies whether a timebase
            cycle is from rising edge to rising edge or from falling
            edge to falling edge.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 322)
        return Edge(val)

    @ci_ctr_timebase_active_edge.setter
    def ci_ctr_timebase_active_edge(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 322, val)

    @ci_ctr_timebase_active_edge.deleter
    def ci_ctr_timebase_active_edge(self):
        cfunc = lib_importer.windll.DAQmxResetCICtrTimebaseActiveEdge
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_ctr_timebase_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8817)
        return val

    @ci_ctr_timebase_dig_fltr_enable.setter
    def ci_ctr_timebase_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8817, val)

    @ci_ctr_timebase_dig_fltr_enable.deleter
    def ci_ctr_timebase_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCICtrTimebaseDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_ctr_timebase_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8818)
        return val

    @ci_ctr_timebase_dig_fltr_min_pulse_width.setter
    def ci_ctr_timebase_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8818, val)

    @ci_ctr_timebase_dig_fltr_min_pulse_width.deleter
    def ci_ctr_timebase_dig_fltr_min_pulse_width(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCICtrTimebaseDigFltrMinPulseWidth)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_ctr_timebase_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8820)
        return val

    @ci_ctr_timebase_dig_fltr_timebase_rate.setter
    def ci_ctr_timebase_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8820, val)

    @ci_ctr_timebase_dig_fltr_timebase_rate.deleter
    def ci_ctr_timebase_dig_fltr_timebase_rate(self):
        cfunc = lib_importer.windll.DAQmxResetCICtrTimebaseDigFltrTimebaseRate
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_ctr_timebase_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8819)
        return val

    @ci_ctr_timebase_dig_fltr_timebase_src.setter
    def ci_ctr_timebase_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8819, val)

    @ci_ctr_timebase_dig_fltr_timebase_src.deleter
    def ci_ctr_timebase_dig_fltr_timebase_src(self):
        cfunc = lib_importer.windll.DAQmxResetCICtrTimebaseDigFltrTimebaseSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_ctr_timebase_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8821)
        return val

    @ci_ctr_timebase_dig_sync_enable.setter
    def ci_ctr_timebase_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8821, val)

    @ci_ctr_timebase_dig_sync_enable.deleter
    def ci_ctr_timebase_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCICtrTimebaseDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_ctr_timebase_master_timebase_div(self):
        """
        int: Specifies the divisor for an external counter timebase. You
            can divide the counter timebase in order to measure slower
            signals without causing the count register to roll over.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 6323)
        return val

    @ci_ctr_timebase_master_timebase_div.setter
    def ci_ctr_timebase_master_timebase_div(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 6323, val)

    @ci_ctr_timebase_master_timebase_div.deleter
    def ci_ctr_timebase_master_timebase_div(self):
        cfunc = lib_importer.windll.DAQmxResetCICtrTimebaseMasterTimebaseDiv
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_ctr_timebase_rate(self):
        """
        float: Specifies in Hertz the frequency of the counter timebase.
            Specifying the rate of a counter timebase allows you to take
            measurements in terms of time or frequency rather than in
            ticks of the timebase. If you use an external timebase and
            do not specify the rate, you can take measurements only in
            terms of ticks of the timebase.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6322)
        return val

    @ci_ctr_timebase_rate.setter
    def ci_ctr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6322, val)

    @ci_ctr_timebase_rate.deleter
    def ci_ctr_timebase_rate(self):
        cfunc = lib_importer.windll.DAQmxResetCICtrTimebaseRate
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_ctr_timebase_src(self):
        """
        str: Specifies the terminal of the timebase to use for the
            counter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 323)
        return val

    @ci_ctr_timebase_src.setter
    def ci_ctr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 323, val)

    @ci_ctr_timebase_src.deleter
    def ci_ctr_timebase_src(self):
        cfunc = lib_importer.windll.DAQmxResetCICtrTimebaseSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_custom_scale(self):
        """
        :class:`nidaqmx.system.scale.Scale`: Specifies the name of a
            custom scale for the channel.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 6302)
        return Scale(val)

    @ci_custom_scale.setter
    def ci_custom_scale(self, val):
        val = val.name
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 6302, val)

    @ci_custom_scale.deleter
    def ci_custom_scale(self):
        cfunc = lib_importer.windll.DAQmxResetCICustomScaleName
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_data_xfer_mech(self):
        """
        :class:`nidaqmx.constants.DataTransferActiveTransferMode`:
            Specifies the data transfer mode for the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 512)
        return DataTransferActiveTransferMode(val)

    @ci_data_xfer_mech.setter
    def ci_data_xfer_mech(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 512, val)

    @ci_data_xfer_mech.deleter
    def ci_data_xfer_mech(self):
        cfunc = lib_importer.windll.DAQmxResetCIDataXferMech
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_data_xfer_req_cond(self):
        """
        :class:`nidaqmx.constants.InputDataTransferCondition`: Specifies
            under what condition to transfer data from the onboard
            memory of the device to the buffer.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12027)
        return InputDataTransferCondition(val)

    @ci_data_xfer_req_cond.setter
    def ci_data_xfer_req_cond(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12027, val)

    @ci_data_xfer_req_cond.deleter
    def ci_data_xfer_req_cond(self):
        cfunc = lib_importer.windll.DAQmxResetCIDataXferReqCond
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_dup_count_prevention(self):
        """
        bool: Specifies whether to enable duplicate count prevention for
            the channel. Duplicate count prevention is enabled by
            default. Setting  **ci_prescaler** disables duplicate count
            prevention unless you explicitly enable it.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8620)
        return val

    @ci_dup_count_prevention.setter
    def ci_dup_count_prevention(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8620, val)

    @ci_dup_count_prevention.deleter
    def ci_dup_count_prevention(self):
        cfunc = lib_importer.windll.DAQmxResetCIDupCountPrevent
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_duty_cycle_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12430)
        return val

    @ci_duty_cycle_dig_fltr_enable.setter
    def ci_duty_cycle_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12430, val)

    @ci_duty_cycle_dig_fltr_enable.deleter
    def ci_duty_cycle_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIDutyCycleDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_duty_cycle_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the digital
            filter recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12431)
        return val

    @ci_duty_cycle_dig_fltr_min_pulse_width.setter
    def ci_duty_cycle_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12431, val)

    @ci_duty_cycle_dig_fltr_min_pulse_width.deleter
    def ci_duty_cycle_dig_fltr_min_pulse_width(self):
        cfunc = lib_importer.windll.DAQmxResetCIDutyCycleDigFltrMinPulseWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_duty_cycle_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12433)
        return val

    @ci_duty_cycle_dig_fltr_timebase_rate.setter
    def ci_duty_cycle_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12433, val)

    @ci_duty_cycle_dig_fltr_timebase_rate.deleter
    def ci_duty_cycle_dig_fltr_timebase_rate(self):
        cfunc = lib_importer.windll.DAQmxResetCIDutyCycleDigFltrTimebaseRate
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_duty_cycle_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12432)
        return val

    @ci_duty_cycle_dig_fltr_timebase_src.setter
    def ci_duty_cycle_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12432, val)

    @ci_duty_cycle_dig_fltr_timebase_src.deleter
    def ci_duty_cycle_dig_fltr_timebase_src(self):
        cfunc = lib_importer.windll.DAQmxResetCIDutyCycleDigFltrTimebaseSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_duty_cycle_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the input line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12450)
        return LogicLvlBehavior(val)

    @ci_duty_cycle_logic_lvl_behavior.setter
    def ci_duty_cycle_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12450, val)

    @ci_duty_cycle_logic_lvl_behavior.deleter
    def ci_duty_cycle_logic_lvl_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCIDutyCycleLogicLvlBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_duty_cycle_starting_edge(self):
        """
        :class:`nidaqmx.constants.Edge`: Specifies which edge of the
            input signal to begin the duty cycle measurement.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12434)
        return Edge(val)

    @ci_duty_cycle_starting_edge.setter
    def ci_duty_cycle_starting_edge(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12434, val)

    @ci_duty_cycle_starting_edge.deleter
    def ci_duty_cycle_starting_edge(self):
        cfunc = lib_importer.windll.DAQmxResetCIDutyCycleStartingEdge
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_duty_cycle_term(self):
        """
        str: Specifies the input terminal of the signal to measure.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12429)
        return val

    @ci_duty_cycle_term.setter
    def ci_duty_cycle_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12429, val)

    @ci_duty_cycle_term.deleter
    def ci_duty_cycle_term(self):
        cfunc = lib_importer.windll.DAQmxResetCIDutyCycleTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_duty_cycle_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12449)
        return TerminalConfiguration(val)

    @ci_duty_cycle_term_cfg.setter
    def ci_duty_cycle_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12449, val)

    @ci_duty_cycle_term_cfg.deleter
    def ci_duty_cycle_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCIDutyCycleTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_a_input_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8699)
        return val

    @ci_encoder_a_input_dig_fltr_enable.setter
    def ci_encoder_a_input_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8699, val)

    @ci_encoder_a_input_dig_fltr_enable.deleter
    def ci_encoder_a_input_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderAInputDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_a_input_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8700)
        return val

    @ci_encoder_a_input_dig_fltr_min_pulse_width.setter
    def ci_encoder_a_input_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8700, val)

    @ci_encoder_a_input_dig_fltr_min_pulse_width.deleter
    def ci_encoder_a_input_dig_fltr_min_pulse_width(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIEncoderAInputDigFltrMinPulseWidth)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_a_input_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8702)
        return val

    @ci_encoder_a_input_dig_fltr_timebase_rate.setter
    def ci_encoder_a_input_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8702, val)

    @ci_encoder_a_input_dig_fltr_timebase_rate.deleter
    def ci_encoder_a_input_dig_fltr_timebase_rate(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIEncoderAInputDigFltrTimebaseRate)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_a_input_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8701)
        return val

    @ci_encoder_a_input_dig_fltr_timebase_src.setter
    def ci_encoder_a_input_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8701, val)

    @ci_encoder_a_input_dig_fltr_timebase_src.deleter
    def ci_encoder_a_input_dig_fltr_timebase_src(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIEncoderAInputDigFltrTimebaseSrc)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_a_input_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8703)
        return val

    @ci_encoder_a_input_dig_sync_enable.setter
    def ci_encoder_a_input_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8703, val)

    @ci_encoder_a_input_dig_sync_enable.deleter
    def ci_encoder_a_input_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderAInputDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_a_input_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the input line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12452)
        return LogicLvlBehavior(val)

    @ci_encoder_a_input_logic_lvl_behavior.setter
    def ci_encoder_a_input_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12452, val)

    @ci_encoder_a_input_logic_lvl_behavior.deleter
    def ci_encoder_a_input_logic_lvl_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderAInputLogicLvlBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_a_input_term(self):
        """
        str: Specifies the terminal to which signal A is connected.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8605)
        return val

    @ci_encoder_a_input_term.setter
    def ci_encoder_a_input_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8605, val)

    @ci_encoder_a_input_term.deleter
    def ci_encoder_a_input_term(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderAInputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_a_input_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12451)
        return TerminalConfiguration(val)

    @ci_encoder_a_input_term_cfg.setter
    def ci_encoder_a_input_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12451, val)

    @ci_encoder_a_input_term_cfg.deleter
    def ci_encoder_a_input_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderAInputTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_b_input_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8704)
        return val

    @ci_encoder_b_input_dig_fltr_enable.setter
    def ci_encoder_b_input_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8704, val)

    @ci_encoder_b_input_dig_fltr_enable.deleter
    def ci_encoder_b_input_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderBInputDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_b_input_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8705)
        return val

    @ci_encoder_b_input_dig_fltr_min_pulse_width.setter
    def ci_encoder_b_input_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8705, val)

    @ci_encoder_b_input_dig_fltr_min_pulse_width.deleter
    def ci_encoder_b_input_dig_fltr_min_pulse_width(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIEncoderBInputDigFltrMinPulseWidth)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_b_input_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8707)
        return val

    @ci_encoder_b_input_dig_fltr_timebase_rate.setter
    def ci_encoder_b_input_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8707, val)

    @ci_encoder_b_input_dig_fltr_timebase_rate.deleter
    def ci_encoder_b_input_dig_fltr_timebase_rate(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIEncoderBInputDigFltrTimebaseRate)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_b_input_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8706)
        return val

    @ci_encoder_b_input_dig_fltr_timebase_src.setter
    def ci_encoder_b_input_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8706, val)

    @ci_encoder_b_input_dig_fltr_timebase_src.deleter
    def ci_encoder_b_input_dig_fltr_timebase_src(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIEncoderBInputDigFltrTimebaseSrc)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_b_input_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8708)
        return val

    @ci_encoder_b_input_dig_sync_enable.setter
    def ci_encoder_b_input_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8708, val)

    @ci_encoder_b_input_dig_sync_enable.deleter
    def ci_encoder_b_input_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderBInputDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_b_input_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the input line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12454)
        return LogicLvlBehavior(val)

    @ci_encoder_b_input_logic_lvl_behavior.setter
    def ci_encoder_b_input_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12454, val)

    @ci_encoder_b_input_logic_lvl_behavior.deleter
    def ci_encoder_b_input_logic_lvl_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderBInputLogicLvlBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_b_input_term(self):
        """
        str: Specifies the terminal to which signal B is connected.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8606)
        return val

    @ci_encoder_b_input_term.setter
    def ci_encoder_b_input_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8606, val)

    @ci_encoder_b_input_term.deleter
    def ci_encoder_b_input_term(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderBInputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_b_input_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12453)
        return TerminalConfiguration(val)

    @ci_encoder_b_input_term_cfg.setter
    def ci_encoder_b_input_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12453, val)

    @ci_encoder_b_input_term_cfg.deleter
    def ci_encoder_b_input_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderBInputTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_decoding_type(self):
        """
        :class:`nidaqmx.constants.EncoderType`: Specifies how to count
            and interpret the pulses the encoder generates on signal A
            and signal B. **EncoderType2.X_1**, **EncoderType2.X_2**,
            and **EncoderType2.X_4** are valid for quadrature encoders
            only. **EncoderType2.TWO_PULSE_COUNTING** is valid for two-
            pulse encoders only.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 8678)
        return EncoderType(val)

    @ci_encoder_decoding_type.setter
    def ci_encoder_decoding_type(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 8678, val)

    @ci_encoder_decoding_type.deleter
    def ci_encoder_decoding_type(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderDecodingType
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_z_index_enable(self):
        """
        bool: Specifies whether to use Z indexing for the channel.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 2192)
        return val

    @ci_encoder_z_index_enable.setter
    def ci_encoder_z_index_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 2192, val)

    @ci_encoder_z_index_enable.deleter
    def ci_encoder_z_index_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderZIndexEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_z_index_phase(self):
        """
        :class:`nidaqmx.constants.EncoderZIndexPhase`: Specifies the
            states at which signal A and signal B must be while signal Z
            is high for NI-DAQmx to reset the measurement. If signal Z
            is never high while signal A and signal B are high, for
            example, you must choose a phase other than
            **EncoderZIndexPhase1.AHIGH_BHIGH**.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 2185)
        return EncoderZIndexPhase(val)

    @ci_encoder_z_index_phase.setter
    def ci_encoder_z_index_phase(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 2185, val)

    @ci_encoder_z_index_phase.deleter
    def ci_encoder_z_index_phase(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderZIndexPhase
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_z_index_val(self):
        """
        float: Specifies the value to which to reset the measurement
            when signal Z is high and signal A and signal B are at the
            states you specify with **ci_encoder_z_index_phase**.
            Specify this value in the units of the measurement.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 2184)
        return val

    @ci_encoder_z_index_val.setter
    def ci_encoder_z_index_val(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 2184, val)

    @ci_encoder_z_index_val.deleter
    def ci_encoder_z_index_val(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderZIndexVal
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_z_input_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8709)
        return val

    @ci_encoder_z_input_dig_fltr_enable.setter
    def ci_encoder_z_input_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8709, val)

    @ci_encoder_z_input_dig_fltr_enable.deleter
    def ci_encoder_z_input_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderZInputDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_z_input_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8710)
        return val

    @ci_encoder_z_input_dig_fltr_min_pulse_width.setter
    def ci_encoder_z_input_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8710, val)

    @ci_encoder_z_input_dig_fltr_min_pulse_width.deleter
    def ci_encoder_z_input_dig_fltr_min_pulse_width(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIEncoderZInputDigFltrMinPulseWidth)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_z_input_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8712)
        return val

    @ci_encoder_z_input_dig_fltr_timebase_rate.setter
    def ci_encoder_z_input_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8712, val)

    @ci_encoder_z_input_dig_fltr_timebase_rate.deleter
    def ci_encoder_z_input_dig_fltr_timebase_rate(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIEncoderZInputDigFltrTimebaseRate)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_z_input_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8711)
        return val

    @ci_encoder_z_input_dig_fltr_timebase_src.setter
    def ci_encoder_z_input_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8711, val)

    @ci_encoder_z_input_dig_fltr_timebase_src.deleter
    def ci_encoder_z_input_dig_fltr_timebase_src(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIEncoderZInputDigFltrTimebaseSrc)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_z_input_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8713)
        return val

    @ci_encoder_z_input_dig_sync_enable.setter
    def ci_encoder_z_input_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8713, val)

    @ci_encoder_z_input_dig_sync_enable.deleter
    def ci_encoder_z_input_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderZInputDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_z_input_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the input line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12456)
        return LogicLvlBehavior(val)

    @ci_encoder_z_input_logic_lvl_behavior.setter
    def ci_encoder_z_input_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12456, val)

    @ci_encoder_z_input_logic_lvl_behavior.deleter
    def ci_encoder_z_input_logic_lvl_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderZInputLogicLvlBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_z_input_term(self):
        """
        str: Specifies the terminal to which signal Z is connected.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8607)
        return val

    @ci_encoder_z_input_term.setter
    def ci_encoder_z_input_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8607, val)

    @ci_encoder_z_input_term.deleter
    def ci_encoder_z_input_term(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderZInputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_encoder_z_input_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12455)
        return TerminalConfiguration(val)

    @ci_encoder_z_input_term_cfg.setter
    def ci_encoder_z_input_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12455, val)

    @ci_encoder_z_input_term_cfg.deleter
    def ci_encoder_z_input_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCIEncoderZInputTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_filter_delay(self):
        """
        float: Indicates the amount of time between when the input
            signal transitions and when the filtered sample is read by
            the host device. This value is in the units specified with
            **ci_filter_delay_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12731)
        return val

    @property
    def ci_filter_delay_units(self):
        """
        :class:`nidaqmx.constants.DigitalWidthUnits`: Specifies the
            units of **ci_filter_delay**.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12732)
        return DigitalWidthUnits(val)

    @ci_filter_delay_units.setter
    def ci_filter_delay_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12732, val)

    @ci_filter_delay_units.deleter
    def ci_filter_delay_units(self):
        cfunc = lib_importer.windll.DAQmxResetCIFilterDelayUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_filter_enable(self):
        """
        bool: Specifies the corresponding filter enable/disable state.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12727)
        return val

    @ci_filter_enable.setter
    def ci_filter_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12727, val)

    @ci_filter_enable.deleter
    def ci_filter_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIFilterEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_filter_freq(self):
        """
        float: Specifies the corresponding filter frequency (cutoff or
            center) of the filter response.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12728)
        return val

    @ci_filter_freq.setter
    def ci_filter_freq(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12728, val)

    @ci_filter_freq.deleter
    def ci_filter_freq(self):
        cfunc = lib_importer.windll.DAQmxResetCIFilterFreq
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_filter_order(self):
        """
        int: Specifies the corresponding filter order and defines the
            slope of the filter response.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 12730)
        return val

    @ci_filter_order.setter
    def ci_filter_order(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 12730, val)

    @ci_filter_order.deleter
    def ci_filter_order(self):
        cfunc = lib_importer.windll.DAQmxResetCIFilterOrder
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_filter_response(self):
        """
        :class:`nidaqmx.constants.FilterResponse`: Specifies the
            corresponding filter response and defines the shape of the
            filter response.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12729)
        return FilterResponse(val)

    @ci_filter_response.setter
    def ci_filter_response(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12729, val)

    @ci_filter_response.deleter
    def ci_filter_response(self):
        cfunc = lib_importer.windll.DAQmxResetCIFilterResponse
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8679)
        return val

    @ci_freq_dig_fltr_enable.setter
    def ci_freq_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8679, val)

    @ci_freq_dig_fltr_enable.deleter
    def ci_freq_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8680)
        return val

    @ci_freq_dig_fltr_min_pulse_width.setter
    def ci_freq_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8680, val)

    @ci_freq_dig_fltr_min_pulse_width.deleter
    def ci_freq_dig_fltr_min_pulse_width(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqDigFltrMinPulseWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8682)
        return val

    @ci_freq_dig_fltr_timebase_rate.setter
    def ci_freq_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8682, val)

    @ci_freq_dig_fltr_timebase_rate.deleter
    def ci_freq_dig_fltr_timebase_rate(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqDigFltrTimebaseRate
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8681)
        return val

    @ci_freq_dig_fltr_timebase_src.setter
    def ci_freq_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8681, val)

    @ci_freq_dig_fltr_timebase_src.deleter
    def ci_freq_dig_fltr_timebase_src(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqDigFltrTimebaseSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8683)
        return val

    @ci_freq_dig_sync_enable.setter
    def ci_freq_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8683, val)

    @ci_freq_dig_sync_enable.deleter
    def ci_freq_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_div(self):
        """
        int: Specifies the value by which to divide the input signal if
            **ci_freq_meas_meth** is
            **CounterFrequencyMethod.LARGE_RANGE_2_COUNTERS**. The
            larger the divisor, the more accurate the measurement.
            However, too large a value could cause the count register to
            roll over, which results in an incorrect measurement.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 327)
        return val

    @ci_freq_div.setter
    def ci_freq_div(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 327, val)

    @ci_freq_div.deleter
    def ci_freq_div(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqDiv
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_enable_averaging(self):
        """
        bool: Specifies whether to enable averaging mode for Sample
            Clock-timed frequency measurements.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 11984)
        return val

    @ci_freq_enable_averaging.setter
    def ci_freq_enable_averaging(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 11984, val)

    @ci_freq_enable_averaging.deleter
    def ci_freq_enable_averaging(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqEnableAveraging
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_hyst(self):
        """
        float: Specifies a hysteresis level to apply to
            **ci_freq_thresh_voltage**. When **ci_freq_starting_edge**
            is rising, the source signal must first fall below
            **ci_freq_thresh_voltage** minus the hysteresis before a
            rising edge is detected at **ci_freq_thresh_voltage**. When
            **ci_freq_starting_edge** is falling, the source signal must
            first rise above **ci_freq_thresh_voltage** plus the
            hysteresis before a falling edge is detected at
            **ci_freq_thresh_voltage**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12716)
        return val

    @ci_freq_hyst.setter
    def ci_freq_hyst(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12716, val)

    @ci_freq_hyst.deleter
    def ci_freq_hyst(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqHyst
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the input line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12440)
        return LogicLvlBehavior(val)

    @ci_freq_logic_lvl_behavior.setter
    def ci_freq_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12440, val)

    @ci_freq_logic_lvl_behavior.deleter
    def ci_freq_logic_lvl_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqLogicLvlBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_meas_meth(self):
        """
        :class:`nidaqmx.constants.CounterFrequencyMethod`: Specifies the
            method to use to measure the frequency of the signal.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 324)
        return CounterFrequencyMethod(val)

    @ci_freq_meas_meth.setter
    def ci_freq_meas_meth(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 324, val)

    @ci_freq_meas_meth.deleter
    def ci_freq_meas_meth(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqMeasMeth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_meas_time(self):
        """
        float: Specifies in seconds the length of time to measure the
            frequency of the signal if **ci_freq_meas_meth** is
            **CounterFrequencyMethod.HIGH_FREQUENCY_2_COUNTERS**.
            Measurement accuracy increases with increased measurement
            time and with increased signal frequency. If you measure a
            high-frequency signal for too long, however, the count
            register could roll over, which results in an incorrect
            measurement.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 325)
        return val

    @ci_freq_meas_time.setter
    def ci_freq_meas_time(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 325, val)

    @ci_freq_meas_time.deleter
    def ci_freq_meas_time(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqMeasTime
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_starting_edge(self):
        """
        :class:`nidaqmx.constants.Edge`: Specifies between which edges
            to measure the frequency of the signal.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 1945)
        return Edge(val)

    @ci_freq_starting_edge.setter
    def ci_freq_starting_edge(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 1945, val)

    @ci_freq_starting_edge.deleter
    def ci_freq_starting_edge(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqStartingEdge
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_term(self):
        """
        str: Specifies the input terminal of the signal to measure.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 6306)
        return val

    @ci_freq_term.setter
    def ci_freq_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 6306, val)

    @ci_freq_term.deleter
    def ci_freq_term(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12439)
        return TerminalConfiguration(val)

    @ci_freq_term_cfg.setter
    def ci_freq_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12439, val)

    @ci_freq_term_cfg.deleter
    def ci_freq_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_thresh_voltage(self):
        """
        float: Specifies the voltage level at which to recognize
            waveform repetitions. Select a voltage level that occurs
            only once within the entire period of a waveform. You also
            can select a voltage that occurs only once while the voltage
            rises or falls.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12715)
        return val

    @ci_freq_thresh_voltage.setter
    def ci_freq_thresh_voltage(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12715, val)

    @ci_freq_thresh_voltage.deleter
    def ci_freq_thresh_voltage(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqThreshVoltage
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_freq_units(self):
        """
        :class:`nidaqmx.constants.FrequencyUnits`: Specifies the units
            to use to return frequency measurements.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6305)
        return FrequencyUnits(val)

    @ci_freq_units.setter
    def ci_freq_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6305, val)

    @ci_freq_units.deleter
    def ci_freq_units(self):
        cfunc = lib_importer.windll.DAQmxResetCIFreqUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_gps_sync_method(self):
        """
        :class:`nidaqmx.constants.GpsSignalType`: Specifies the method
            to use to synchronize the counter to a GPS receiver.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 4242)
        return GpsSignalType(val)

    @ci_gps_sync_method.setter
    def ci_gps_sync_method(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 4242, val)

    @ci_gps_sync_method.deleter
    def ci_gps_sync_method(self):
        cfunc = lib_importer.windll.DAQmxResetCIGPSSyncMethod
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_gps_sync_src(self):
        """
        str: Specifies the terminal to which the GPS synchronization
            signal is connected.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 4243)
        return val

    @ci_gps_sync_src.setter
    def ci_gps_sync_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 4243, val)

    @ci_gps_sync_src.deleter
    def ci_gps_sync_src(self):
        cfunc = lib_importer.windll.DAQmxResetCIGPSSyncSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_lin_encoder_dist_per_pulse(self):
        """
        float: Specifies the distance to measure for each pulse the
            encoder generates on signal A or signal B. This value is in
            the units you specify with **ci_lin_encoder_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 2321)
        return val

    @ci_lin_encoder_dist_per_pulse.setter
    def ci_lin_encoder_dist_per_pulse(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 2321, val)

    @ci_lin_encoder_dist_per_pulse.deleter
    def ci_lin_encoder_dist_per_pulse(self):
        cfunc = lib_importer.windll.DAQmxResetCILinEncoderDistPerPulse
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_lin_encoder_initial_pos(self):
        """
        float: Specifies the position of the encoder when the
            measurement begins. This value is in the units you specify
            with **ci_lin_encoder_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 2325)
        return val

    @ci_lin_encoder_initial_pos.setter
    def ci_lin_encoder_initial_pos(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 2325, val)

    @ci_lin_encoder_initial_pos.deleter
    def ci_lin_encoder_initial_pos(self):
        cfunc = lib_importer.windll.DAQmxResetCILinEncoderInitialPos
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_lin_encoder_units(self):
        """
        :class:`nidaqmx.constants.LengthUnits`: Specifies the units to
            use to return linear encoder measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6313)
        return LengthUnits(val)

    @ci_lin_encoder_units.setter
    def ci_lin_encoder_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6313, val)

    @ci_lin_encoder_units.deleter
    def ci_lin_encoder_units(self):
        cfunc = lib_importer.windll.DAQmxResetCILinEncoderUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_max(self):
        """
        float: Specifies the maximum value you expect to measure. This
            value is in the units you specify with a units property.
            When you query this property, it returns the coerced maximum
            value that the hardware can measure with the current
            settings.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6300)
        return val

    @ci_max.setter
    def ci_max(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6300, val)

    @ci_max.deleter
    def ci_max(self):
        cfunc = lib_importer.windll.DAQmxResetCIMax
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_max_meas_period(self):
        """
        float: Specifies the maximum period (in seconds) in which the
            device will recognize signals. For frequency measurements, a
            signal with a higher period than the one set in this
            property will return 0 Hz. For duty cycle, the device will
            return 0 or 1 depending on the state of the line during the
            max defined period of time. Period measurements will return
            NaN. Pulse width measurement will return zero.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12437)
        return val

    @ci_max_meas_period.setter
    def ci_max_meas_period(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12437, val)

    @ci_max_meas_period.deleter
    def ci_max_meas_period(self):
        cfunc = lib_importer.windll.DAQmxResetCIMaxMeasPeriod
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_meas_type(self):
        """
        :class:`nidaqmx.constants.UsageTypeCI`: Indicates the
            measurement to take with the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6304)
        return UsageTypeCI(val)

    @property
    def ci_mem_map_enable(self):
        """
        bool: Specifies for NI-DAQmx to map hardware registers to the
            memory space of the application, if possible. Normally, NI-
            DAQmx maps hardware registers to memory accessible only to
            the kernel. Mapping the registers to the memory space of the
            application increases performance. However, if the
            application accesses the memory space mapped to the
            registers, it can adversely affect the operation of the
            device and possibly result in a system crash.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 11986)
        return val

    @ci_mem_map_enable.setter
    def ci_mem_map_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 11986, val)

    @ci_mem_map_enable.deleter
    def ci_mem_map_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIMemMapEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_min(self):
        """
        float: Specifies the minimum value you expect to measure. This
            value is in the units you specify with a units property.
            When you query this property, it returns the coerced minimum
            value that the hardware can measure with the current
            settings.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6301)
        return val

    @ci_min.setter
    def ci_min(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6301, val)

    @ci_min.deleter
    def ci_min(self):
        cfunc = lib_importer.windll.DAQmxResetCIMin
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_num_possibly_invalid_samps(self):
        """
        int: Indicates the number of samples that the device might have
            overwritten before it could transfer them to the buffer.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 6460)
        return val

    @property
    def ci_output_state(self):
        """
        :class:`nidaqmx.constants.Level`: Indicates the current state of
            the out terminal of the counter.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 329)
        return Level(val)

    @property
    def ci_period_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8684)
        return val

    @ci_period_dig_fltr_enable.setter
    def ci_period_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8684, val)

    @ci_period_dig_fltr_enable.deleter
    def ci_period_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8685)
        return val

    @ci_period_dig_fltr_min_pulse_width.setter
    def ci_period_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8685, val)

    @ci_period_dig_fltr_min_pulse_width.deleter
    def ci_period_dig_fltr_min_pulse_width(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodDigFltrMinPulseWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8687)
        return val

    @ci_period_dig_fltr_timebase_rate.setter
    def ci_period_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8687, val)

    @ci_period_dig_fltr_timebase_rate.deleter
    def ci_period_dig_fltr_timebase_rate(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodDigFltrTimebaseRate
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8686)
        return val

    @ci_period_dig_fltr_timebase_src.setter
    def ci_period_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8686, val)

    @ci_period_dig_fltr_timebase_src.deleter
    def ci_period_dig_fltr_timebase_src(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodDigFltrTimebaseSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8688)
        return val

    @ci_period_dig_sync_enable.setter
    def ci_period_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8688, val)

    @ci_period_dig_sync_enable.deleter
    def ci_period_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_div(self):
        """
        int: Specifies the value by which to divide the input signal if
            **ci_period_meas_meth** is
            **CounterFrequencyMethod.LARGE_RANGE_2_COUNTERS**. The
            larger the divisor, the more accurate the measurement.
            However, too large a value could cause the count register to
            roll over, which results in an incorrect measurement.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 6446)
        return val

    @ci_period_div.setter
    def ci_period_div(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 6446, val)

    @ci_period_div.deleter
    def ci_period_div(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodDiv
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_enable_averaging(self):
        """
        bool: Specifies whether to enable averaging mode for Sample
            Clock-timed period measurements.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 11985)
        return val

    @ci_period_enable_averaging.setter
    def ci_period_enable_averaging(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 11985, val)

    @ci_period_enable_averaging.deleter
    def ci_period_enable_averaging(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodEnableAveraging
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_hyst(self):
        """
        float: Specifies a hysteresis level to apply to
            **ci_period_thresh_voltage**. When
            **ci_period_starting_edge** is rising, the source signal
            must first fall below **ci_period_thresh_voltage** minus the
            hysteresis before a rising edge is detected at
            **ci_period_thresh_voltage**. When
            **ci_period_starting_edge** is falling, the source signal
            must first rise above **ci_period_thresh_voltage** plus the
            hysteresis before a falling edge is detected at
            **ci_period_thresh_voltage**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12718)
        return val

    @ci_period_hyst.setter
    def ci_period_hyst(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12718, val)

    @ci_period_hyst.deleter
    def ci_period_hyst(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodHyst
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the input line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12442)
        return LogicLvlBehavior(val)

    @ci_period_logic_lvl_behavior.setter
    def ci_period_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12442, val)

    @ci_period_logic_lvl_behavior.deleter
    def ci_period_logic_lvl_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodLogicLvlBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_meas_meth(self):
        """
        :class:`nidaqmx.constants.CounterFrequencyMethod`: Specifies the
            method to use to measure the period of the signal.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6444)
        return CounterFrequencyMethod(val)

    @ci_period_meas_meth.setter
    def ci_period_meas_meth(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6444, val)

    @ci_period_meas_meth.deleter
    def ci_period_meas_meth(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodMeasMeth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_meas_time(self):
        """
        float: Specifies in seconds the length of time to measure the
            period of the signal if **ci_period_meas_meth** is
            **CounterFrequencyMethod.HIGH_FREQUENCY_2_COUNTERS**.
            Measurement accuracy increases with increased measurement
            time and with increased signal frequency. If you measure a
            high-frequency signal for too long, however, the count
            register could roll over, which results in an incorrect
            measurement.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6445)
        return val

    @ci_period_meas_time.setter
    def ci_period_meas_time(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6445, val)

    @ci_period_meas_time.deleter
    def ci_period_meas_time(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodMeasTime
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_starting_edge(self):
        """
        :class:`nidaqmx.constants.Edge`: Specifies between which edges
            to measure the period of the signal.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 2130)
        return Edge(val)

    @ci_period_starting_edge.setter
    def ci_period_starting_edge(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 2130, val)

    @ci_period_starting_edge.deleter
    def ci_period_starting_edge(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodStartingEdge
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_term(self):
        """
        str: Specifies the input terminal of the signal to measure.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 6308)
        return val

    @ci_period_term.setter
    def ci_period_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 6308, val)

    @ci_period_term.deleter
    def ci_period_term(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12441)
        return TerminalConfiguration(val)

    @ci_period_term_cfg.setter
    def ci_period_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12441, val)

    @ci_period_term_cfg.deleter
    def ci_period_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_thresh_voltage(self):
        """
        float: Specifies the voltage level at which to recognize
            waveform repetitions. Select a voltage level that occurs
            only once within the entire period of a waveform. You also
            can select a voltage that occurs only once while the voltage
            rises or falls.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12717)
        return val

    @ci_period_thresh_voltage.setter
    def ci_period_thresh_voltage(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12717, val)

    @ci_period_thresh_voltage.deleter
    def ci_period_thresh_voltage(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodThreshVoltage
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_period_units(self):
        """
        :class:`nidaqmx.constants.TimeUnits`: Specifies the unit to use
            to return period measurements.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6307)
        return TimeUnits(val)

    @ci_period_units.setter
    def ci_period_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6307, val)

    @ci_period_units.deleter
    def ci_period_units(self):
        cfunc = lib_importer.windll.DAQmxResetCIPeriodUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_prescaler(self):
        """
        int: Specifies the divisor to apply to the signal you connect to
            the counter source terminal. Scaled data that you read takes
            this setting into account. You should use a prescaler only
            when you connect an external signal to the counter source
            terminal and when that signal has a higher frequency than
            the fastest onboard timebase. Setting this value disables
            duplicate count prevention unless you explicitly set
            **ci_dup_count_prevention** to True.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 8761)
        return val

    @ci_prescaler.setter
    def ci_prescaler(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 8761, val)

    @ci_prescaler.deleter
    def ci_prescaler(self):
        cfunc = lib_importer.windll.DAQmxResetCIPrescaler
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_freq_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply a digital filter to the signal
            to measure.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12038)
        return val

    @ci_pulse_freq_dig_fltr_enable.setter
    def ci_pulse_freq_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12038, val)

    @ci_pulse_freq_dig_fltr_enable.deleter
    def ci_pulse_freq_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseFreqDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_freq_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12039)
        return val

    @ci_pulse_freq_dig_fltr_min_pulse_width.setter
    def ci_pulse_freq_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12039, val)

    @ci_pulse_freq_dig_fltr_min_pulse_width.deleter
    def ci_pulse_freq_dig_fltr_min_pulse_width(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseFreqDigFltrMinPulseWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_freq_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the digital filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12041)
        return val

    @ci_pulse_freq_dig_fltr_timebase_rate.setter
    def ci_pulse_freq_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12041, val)

    @ci_pulse_freq_dig_fltr_timebase_rate.deleter
    def ci_pulse_freq_dig_fltr_timebase_rate(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseFreqDigFltrTimebaseRate
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_freq_dig_fltr_timebase_src(self):
        """
        str: Specifies the terminal of the signal to use as the timebase
            of the digital filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12040)
        return val

    @ci_pulse_freq_dig_fltr_timebase_src.setter
    def ci_pulse_freq_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12040, val)

    @ci_pulse_freq_dig_fltr_timebase_src.deleter
    def ci_pulse_freq_dig_fltr_timebase_src(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseFreqDigFltrTimebaseSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_freq_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12042)
        return val

    @ci_pulse_freq_dig_sync_enable.setter
    def ci_pulse_freq_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12042, val)

    @ci_pulse_freq_dig_sync_enable.deleter
    def ci_pulse_freq_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseFreqDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_freq_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the count reset line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12466)
        return LogicLvlBehavior(val)

    @ci_pulse_freq_logic_lvl_behavior.setter
    def ci_pulse_freq_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12466, val)

    @ci_pulse_freq_logic_lvl_behavior.deleter
    def ci_pulse_freq_logic_lvl_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseFreqLogicLvlBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_freq_starting_edge(self):
        """
        :class:`nidaqmx.constants.Edge`: Specifies on which edge of the
            input signal to begin pulse measurement.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12037)
        return Edge(val)

    @ci_pulse_freq_starting_edge.setter
    def ci_pulse_freq_starting_edge(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12037, val)

    @ci_pulse_freq_starting_edge.deleter
    def ci_pulse_freq_starting_edge(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseFreqStartEdge
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_freq_term(self):
        """
        str: Specifies the input terminal of the signal to measure.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12036)
        return val

    @ci_pulse_freq_term.setter
    def ci_pulse_freq_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12036, val)

    @ci_pulse_freq_term.deleter
    def ci_pulse_freq_term(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseFreqTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_freq_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12465)
        return TerminalConfiguration(val)

    @ci_pulse_freq_term_cfg.setter
    def ci_pulse_freq_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12465, val)

    @ci_pulse_freq_term_cfg.deleter
    def ci_pulse_freq_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseFreqTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_freq_units(self):
        """
        :class:`nidaqmx.constants.FrequencyUnits`: Specifies the units
            to use to return pulse specifications in terms of frequency.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12043)
        return FrequencyUnits(val)

    @ci_pulse_freq_units.setter
    def ci_pulse_freq_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12043, val)

    @ci_pulse_freq_units.deleter
    def ci_pulse_freq_units(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseFreqUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_ticks_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply a digital filter to the signal
            to measure.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12054)
        return val

    @ci_pulse_ticks_dig_fltr_enable.setter
    def ci_pulse_ticks_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12054, val)

    @ci_pulse_ticks_dig_fltr_enable.deleter
    def ci_pulse_ticks_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTicksDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_ticks_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12055)
        return val

    @ci_pulse_ticks_dig_fltr_min_pulse_width.setter
    def ci_pulse_ticks_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12055, val)

    @ci_pulse_ticks_dig_fltr_min_pulse_width.deleter
    def ci_pulse_ticks_dig_fltr_min_pulse_width(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTicksDigFltrMinPulseWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_ticks_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the digital filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12057)
        return val

    @ci_pulse_ticks_dig_fltr_timebase_rate.setter
    def ci_pulse_ticks_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12057, val)

    @ci_pulse_ticks_dig_fltr_timebase_rate.deleter
    def ci_pulse_ticks_dig_fltr_timebase_rate(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTicksDigFltrTimebaseRate
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_ticks_dig_fltr_timebase_src(self):
        """
        str: Specifies the terminal of the signal to use as the timebase
            of the digital filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12056)
        return val

    @ci_pulse_ticks_dig_fltr_timebase_src.setter
    def ci_pulse_ticks_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12056, val)

    @ci_pulse_ticks_dig_fltr_timebase_src.deleter
    def ci_pulse_ticks_dig_fltr_timebase_src(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTicksDigFltrTimebaseSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_ticks_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12058)
        return val

    @ci_pulse_ticks_dig_sync_enable.setter
    def ci_pulse_ticks_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12058, val)

    @ci_pulse_ticks_dig_sync_enable.deleter
    def ci_pulse_ticks_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTicksDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_ticks_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the count reset line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12470)
        return LogicLvlBehavior(val)

    @ci_pulse_ticks_logic_lvl_behavior.setter
    def ci_pulse_ticks_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12470, val)

    @ci_pulse_ticks_logic_lvl_behavior.deleter
    def ci_pulse_ticks_logic_lvl_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTicksLogicLvlBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_ticks_starting_edge(self):
        """
        :class:`nidaqmx.constants.Edge`: Specifies on which edge of the
            input signal to begin pulse measurement.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12053)
        return Edge(val)

    @ci_pulse_ticks_starting_edge.setter
    def ci_pulse_ticks_starting_edge(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12053, val)

    @ci_pulse_ticks_starting_edge.deleter
    def ci_pulse_ticks_starting_edge(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTicksStartEdge
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_ticks_term(self):
        """
        str: Specifies the input terminal of the signal to measure.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12052)
        return val

    @ci_pulse_ticks_term.setter
    def ci_pulse_ticks_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12052, val)

    @ci_pulse_ticks_term.deleter
    def ci_pulse_ticks_term(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTicksTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_ticks_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12469)
        return TerminalConfiguration(val)

    @ci_pulse_ticks_term_cfg.setter
    def ci_pulse_ticks_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12469, val)

    @ci_pulse_ticks_term_cfg.deleter
    def ci_pulse_ticks_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTicksTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_time_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply a digital filter to the signal
            to measure.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12046)
        return val

    @ci_pulse_time_dig_fltr_enable.setter
    def ci_pulse_time_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12046, val)

    @ci_pulse_time_dig_fltr_enable.deleter
    def ci_pulse_time_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTimeDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_time_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12047)
        return val

    @ci_pulse_time_dig_fltr_min_pulse_width.setter
    def ci_pulse_time_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12047, val)

    @ci_pulse_time_dig_fltr_min_pulse_width.deleter
    def ci_pulse_time_dig_fltr_min_pulse_width(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTimeDigFltrMinPulseWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_time_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the digital filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12049)
        return val

    @ci_pulse_time_dig_fltr_timebase_rate.setter
    def ci_pulse_time_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12049, val)

    @ci_pulse_time_dig_fltr_timebase_rate.deleter
    def ci_pulse_time_dig_fltr_timebase_rate(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTimeDigFltrTimebaseRate
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_time_dig_fltr_timebase_src(self):
        """
        str: Specifies the terminal of the signal to use as the timebase
            of the digital filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12048)
        return val

    @ci_pulse_time_dig_fltr_timebase_src.setter
    def ci_pulse_time_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12048, val)

    @ci_pulse_time_dig_fltr_timebase_src.deleter
    def ci_pulse_time_dig_fltr_timebase_src(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTimeDigFltrTimebaseSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_time_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12050)
        return val

    @ci_pulse_time_dig_sync_enable.setter
    def ci_pulse_time_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12050, val)

    @ci_pulse_time_dig_sync_enable.deleter
    def ci_pulse_time_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTimeDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_time_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the count reset line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12468)
        return LogicLvlBehavior(val)

    @ci_pulse_time_logic_lvl_behavior.setter
    def ci_pulse_time_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12468, val)

    @ci_pulse_time_logic_lvl_behavior.deleter
    def ci_pulse_time_logic_lvl_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTimeLogicLvlBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_time_starting_edge(self):
        """
        :class:`nidaqmx.constants.Edge`: Specifies on which edge of the
            input signal to begin pulse measurement.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12045)
        return Edge(val)

    @ci_pulse_time_starting_edge.setter
    def ci_pulse_time_starting_edge(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12045, val)

    @ci_pulse_time_starting_edge.deleter
    def ci_pulse_time_starting_edge(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTimeStartEdge
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_time_term(self):
        """
        str: Specifies the input terminal of the signal to measure.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12044)
        return val

    @ci_pulse_time_term.setter
    def ci_pulse_time_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12044, val)

    @ci_pulse_time_term.deleter
    def ci_pulse_time_term(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTimeTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_time_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12467)
        return TerminalConfiguration(val)

    @ci_pulse_time_term_cfg.setter
    def ci_pulse_time_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12467, val)

    @ci_pulse_time_term_cfg.deleter
    def ci_pulse_time_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTimeTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_time_units(self):
        """
        :class:`nidaqmx.constants.TimeUnits`: Specifies the units to use
            to return pulse specifications in terms of high time and low
            time.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12051)
        return TimeUnits(val)

    @ci_pulse_time_units.setter
    def ci_pulse_time_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12051, val)

    @ci_pulse_time_units.deleter
    def ci_pulse_time_units(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseTimeUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_width_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8714)
        return val

    @ci_pulse_width_dig_fltr_enable.setter
    def ci_pulse_width_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8714, val)

    @ci_pulse_width_dig_fltr_enable.deleter
    def ci_pulse_width_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseWidthDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_width_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8715)
        return val

    @ci_pulse_width_dig_fltr_min_pulse_width.setter
    def ci_pulse_width_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8715, val)

    @ci_pulse_width_dig_fltr_min_pulse_width.deleter
    def ci_pulse_width_dig_fltr_min_pulse_width(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseWidthDigFltrMinPulseWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_width_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8717)
        return val

    @ci_pulse_width_dig_fltr_timebase_rate.setter
    def ci_pulse_width_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8717, val)

    @ci_pulse_width_dig_fltr_timebase_rate.deleter
    def ci_pulse_width_dig_fltr_timebase_rate(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseWidthDigFltrTimebaseRate
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_width_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8716)
        return val

    @ci_pulse_width_dig_fltr_timebase_src.setter
    def ci_pulse_width_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8716, val)

    @ci_pulse_width_dig_fltr_timebase_src.deleter
    def ci_pulse_width_dig_fltr_timebase_src(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseWidthDigFltrTimebaseSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_width_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8718)
        return val

    @ci_pulse_width_dig_sync_enable.setter
    def ci_pulse_width_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8718, val)

    @ci_pulse_width_dig_sync_enable.deleter
    def ci_pulse_width_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseWidthDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_width_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the input line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12458)
        return LogicLvlBehavior(val)

    @ci_pulse_width_logic_lvl_behavior.setter
    def ci_pulse_width_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12458, val)

    @ci_pulse_width_logic_lvl_behavior.deleter
    def ci_pulse_width_logic_lvl_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseWidthLogicLvlBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_width_starting_edge(self):
        """
        :class:`nidaqmx.constants.Edge`: Specifies on which edge of the
            input signal to begin each pulse width measurement.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 2085)
        return Edge(val)

    @ci_pulse_width_starting_edge.setter
    def ci_pulse_width_starting_edge(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 2085, val)

    @ci_pulse_width_starting_edge.deleter
    def ci_pulse_width_starting_edge(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseWidthStartingEdge
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_width_term(self):
        """
        str: Specifies the input terminal of the signal to measure.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 6314)
        return val

    @ci_pulse_width_term.setter
    def ci_pulse_width_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 6314, val)

    @ci_pulse_width_term.deleter
    def ci_pulse_width_term(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseWidthTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_width_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12457)
        return TerminalConfiguration(val)

    @ci_pulse_width_term_cfg.setter
    def ci_pulse_width_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12457, val)

    @ci_pulse_width_term_cfg.deleter
    def ci_pulse_width_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseWidthTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_pulse_width_units(self):
        """
        :class:`nidaqmx.constants.TimeUnits`: Specifies the units to use
            to return pulse width measurements.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 2083)
        return TimeUnits(val)

    @ci_pulse_width_units.setter
    def ci_pulse_width_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 2083, val)

    @ci_pulse_width_units.deleter
    def ci_pulse_width_units(self):
        cfunc = lib_importer.windll.DAQmxResetCIPulseWidthUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_samp_clk_overrun_behavior(self):
        """
        :class:`nidaqmx.constants.SampClkOverrunBehavior`: Specifies the
            counter behavior when data is read but a new value was not
            detected during a sample clock.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12435)
        return SampClkOverrunBehavior(val)

    @ci_samp_clk_overrun_behavior.setter
    def ci_samp_clk_overrun_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12435, val)

    @ci_samp_clk_overrun_behavior.deleter
    def ci_samp_clk_overrun_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCISampClkOverrunBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_samp_clk_overrun_sentinel_val(self):
        """
        int: Specifies the sentinel value returned when the No New
            Sample Behavior is set to Sentinel Value.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12436)
        return val

    @ci_samp_clk_overrun_sentinel_val.setter
    def ci_samp_clk_overrun_sentinel_val(self, val):
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12436, val)

    @ci_samp_clk_overrun_sentinel_val.deleter
    def ci_samp_clk_overrun_sentinel_val(self):
        cfunc = lib_importer.windll.DAQmxResetCISampClkOverrunSentinelVal
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_semi_period_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8729)
        return val

    @ci_semi_period_dig_fltr_enable.setter
    def ci_semi_period_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8729, val)

    @ci_semi_period_dig_fltr_enable.deleter
    def ci_semi_period_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCISemiPeriodDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_semi_period_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8730)
        return val

    @ci_semi_period_dig_fltr_min_pulse_width.setter
    def ci_semi_period_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8730, val)

    @ci_semi_period_dig_fltr_min_pulse_width.deleter
    def ci_semi_period_dig_fltr_min_pulse_width(self):
        cfunc = lib_importer.windll.DAQmxResetCISemiPeriodDigFltrMinPulseWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_semi_period_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8732)
        return val

    @ci_semi_period_dig_fltr_timebase_rate.setter
    def ci_semi_period_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8732, val)

    @ci_semi_period_dig_fltr_timebase_rate.deleter
    def ci_semi_period_dig_fltr_timebase_rate(self):
        cfunc = lib_importer.windll.DAQmxResetCISemiPeriodDigFltrTimebaseRate
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_semi_period_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8731)
        return val

    @ci_semi_period_dig_fltr_timebase_src.setter
    def ci_semi_period_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8731, val)

    @ci_semi_period_dig_fltr_timebase_src.deleter
    def ci_semi_period_dig_fltr_timebase_src(self):
        cfunc = lib_importer.windll.DAQmxResetCISemiPeriodDigFltrTimebaseSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_semi_period_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8733)
        return val

    @ci_semi_period_dig_sync_enable.setter
    def ci_semi_period_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8733, val)

    @ci_semi_period_dig_sync_enable.deleter
    def ci_semi_period_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCISemiPeriodDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_semi_period_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the count reset line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12464)
        return LogicLvlBehavior(val)

    @ci_semi_period_logic_lvl_behavior.setter
    def ci_semi_period_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12464, val)

    @ci_semi_period_logic_lvl_behavior.deleter
    def ci_semi_period_logic_lvl_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetCISemiPeriodLogicLvlBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_semi_period_starting_edge(self):
        """
        :class:`nidaqmx.constants.Edge`: Specifies on which edge of the
            input signal to begin semi-period measurement. Semi-period
            measurements alternate between high time and low time,
            starting on this edge.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 8958)
        return Edge(val)

    @ci_semi_period_starting_edge.setter
    def ci_semi_period_starting_edge(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 8958, val)

    @ci_semi_period_starting_edge.deleter
    def ci_semi_period_starting_edge(self):
        cfunc = lib_importer.windll.DAQmxResetCISemiPeriodStartingEdge
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_semi_period_term(self):
        """
        str: Specifies the input terminal of the signal to measure.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 6320)
        return val

    @ci_semi_period_term.setter
    def ci_semi_period_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 6320, val)

    @ci_semi_period_term.deleter
    def ci_semi_period_term(self):
        cfunc = lib_importer.windll.DAQmxResetCISemiPeriodTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_semi_period_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12463)
        return TerminalConfiguration(val)

    @ci_semi_period_term_cfg.setter
    def ci_semi_period_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12463, val)

    @ci_semi_period_term_cfg.deleter
    def ci_semi_period_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCISemiPeriodTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_semi_period_units(self):
        """
        :class:`nidaqmx.constants.TimeUnits`: Specifies the units to use
            to return semi-period measurements.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6319)
        return TimeUnits(val)

    @ci_semi_period_units.setter
    def ci_semi_period_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6319, val)

    @ci_semi_period_units.deleter
    def ci_semi_period_units(self):
        cfunc = lib_importer.windll.DAQmxResetCISemiPeriodUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_tc_reached(self):
        """
        bool: Indicates whether the counter rolled over. When you query
            this property, NI-DAQmx resets it to False.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 336)
        return val

    @property
    def ci_thresh_voltage(self):
        """
        float: Specifies the digital threshold value in Volts for high
            and low input transitions. Some devices do not support this
            for differential channels.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12471)
        return val

    @ci_thresh_voltage.setter
    def ci_thresh_voltage(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12471, val)

    @ci_thresh_voltage.deleter
    def ci_thresh_voltage(self):
        cfunc = lib_importer.windll.DAQmxResetCIThreshVoltage
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_timestamp_initial_seconds(self):
        """
        int: Specifies the number of seconds that elapsed since the
            beginning of the current year. This value is ignored if
            **ci_gps_sync_method** is **GpsSignalType1.IRIGB**.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 8884)
        return val

    @ci_timestamp_initial_seconds.setter
    def ci_timestamp_initial_seconds(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 8884, val)

    @ci_timestamp_initial_seconds.deleter
    def ci_timestamp_initial_seconds(self):
        cfunc = lib_importer.windll.DAQmxResetCITimestampInitialSeconds
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_timestamp_units(self):
        """
        :class:`nidaqmx.constants.TimeUnits`: Specifies the units to use
            to return timestamp measurements.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 8883)
        return TimeUnits(val)

    @ci_timestamp_units.setter
    def ci_timestamp_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 8883, val)

    @ci_timestamp_units.deleter
    def ci_timestamp_units(self):
        cfunc = lib_importer.windll.DAQmxResetCITimestampUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_first_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8719)
        return val

    @ci_two_edge_sep_first_dig_fltr_enable.setter
    def ci_two_edge_sep_first_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8719, val)

    @ci_two_edge_sep_first_dig_fltr_enable.deleter
    def ci_two_edge_sep_first_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCITwoEdgeSepFirstDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_first_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8720)
        return val

    @ci_two_edge_sep_first_dig_fltr_min_pulse_width.setter
    def ci_two_edge_sep_first_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8720, val)

    @ci_two_edge_sep_first_dig_fltr_min_pulse_width.deleter
    def ci_two_edge_sep_first_dig_fltr_min_pulse_width(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCITwoEdgeSepFirstDigFltrMinPulseWidth)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_first_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8722)
        return val

    @ci_two_edge_sep_first_dig_fltr_timebase_rate.setter
    def ci_two_edge_sep_first_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8722, val)

    @ci_two_edge_sep_first_dig_fltr_timebase_rate.deleter
    def ci_two_edge_sep_first_dig_fltr_timebase_rate(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCITwoEdgeSepFirstDigFltrTimebaseRate)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_first_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8721)
        return val

    @ci_two_edge_sep_first_dig_fltr_timebase_src.setter
    def ci_two_edge_sep_first_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8721, val)

    @ci_two_edge_sep_first_dig_fltr_timebase_src.deleter
    def ci_two_edge_sep_first_dig_fltr_timebase_src(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCITwoEdgeSepFirstDigFltrTimebaseSrc)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_first_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8723)
        return val

    @ci_two_edge_sep_first_dig_sync_enable.setter
    def ci_two_edge_sep_first_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8723, val)

    @ci_two_edge_sep_first_dig_sync_enable.deleter
    def ci_two_edge_sep_first_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCITwoEdgeSepFirstDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_first_edge(self):
        """
        :class:`nidaqmx.constants.Edge`: Specifies on which edge of the
            first signal to start each measurement.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 2099)
        return Edge(val)

    @ci_two_edge_sep_first_edge.setter
    def ci_two_edge_sep_first_edge(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 2099, val)

    @ci_two_edge_sep_first_edge.deleter
    def ci_two_edge_sep_first_edge(self):
        cfunc = lib_importer.windll.DAQmxResetCITwoEdgeSepFirstEdge
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_first_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the input line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12460)
        return LogicLvlBehavior(val)

    @ci_two_edge_sep_first_logic_lvl_behavior.setter
    def ci_two_edge_sep_first_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12460, val)

    @ci_two_edge_sep_first_logic_lvl_behavior.deleter
    def ci_two_edge_sep_first_logic_lvl_behavior(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCITwoEdgeSepFirstLogicLvlBehavior)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_first_term(self):
        """
        str: Specifies the source terminal of the digital signal that
            starts each measurement.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 6317)
        return val

    @ci_two_edge_sep_first_term.setter
    def ci_two_edge_sep_first_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 6317, val)

    @ci_two_edge_sep_first_term.deleter
    def ci_two_edge_sep_first_term(self):
        cfunc = lib_importer.windll.DAQmxResetCITwoEdgeSepFirstTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_first_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12459)
        return TerminalConfiguration(val)

    @ci_two_edge_sep_first_term_cfg.setter
    def ci_two_edge_sep_first_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12459, val)

    @ci_two_edge_sep_first_term_cfg.deleter
    def ci_two_edge_sep_first_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCITwoEdgeSepFirstTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_second_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8724)
        return val

    @ci_two_edge_sep_second_dig_fltr_enable.setter
    def ci_two_edge_sep_second_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8724, val)

    @ci_two_edge_sep_second_dig_fltr_enable.deleter
    def ci_two_edge_sep_second_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCITwoEdgeSepSecondDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_second_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the filter
            recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8725)
        return val

    @ci_two_edge_sep_second_dig_fltr_min_pulse_width.setter
    def ci_two_edge_sep_second_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8725, val)

    @ci_two_edge_sep_second_dig_fltr_min_pulse_width.deleter
    def ci_two_edge_sep_second_dig_fltr_min_pulse_width(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCITwoEdgeSepSecondDigFltrMinPulseWidth)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_second_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8727)
        return val

    @ci_two_edge_sep_second_dig_fltr_timebase_rate.setter
    def ci_two_edge_sep_second_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8727, val)

    @ci_two_edge_sep_second_dig_fltr_timebase_rate.deleter
    def ci_two_edge_sep_second_dig_fltr_timebase_rate(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCITwoEdgeSepSecondDigFltrTimebaseRate)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_second_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8726)
        return val

    @ci_two_edge_sep_second_dig_fltr_timebase_src.setter
    def ci_two_edge_sep_second_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8726, val)

    @ci_two_edge_sep_second_dig_fltr_timebase_src.deleter
    def ci_two_edge_sep_second_dig_fltr_timebase_src(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCITwoEdgeSepSecondDigFltrTimebaseSrc)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_second_dig_sync_enable(self):
        """
        bool: Specifies whether to synchronize recognition of
            transitions in the signal to the internal timebase of the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8728)
        return val

    @ci_two_edge_sep_second_dig_sync_enable.setter
    def ci_two_edge_sep_second_dig_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8728, val)

    @ci_two_edge_sep_second_dig_sync_enable.deleter
    def ci_two_edge_sep_second_dig_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetCITwoEdgeSepSecondDigSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_second_edge(self):
        """
        :class:`nidaqmx.constants.Edge`: Specifies on which edge of the
            second signal to stop each measurement.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 2100)
        return Edge(val)

    @ci_two_edge_sep_second_edge.setter
    def ci_two_edge_sep_second_edge(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 2100, val)

    @ci_two_edge_sep_second_edge.deleter
    def ci_two_edge_sep_second_edge(self):
        cfunc = lib_importer.windll.DAQmxResetCITwoEdgeSepSecondEdge
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_second_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior on the count reset line.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12462)
        return LogicLvlBehavior(val)

    @ci_two_edge_sep_second_logic_lvl_behavior.setter
    def ci_two_edge_sep_second_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12462, val)

    @ci_two_edge_sep_second_logic_lvl_behavior.deleter
    def ci_two_edge_sep_second_logic_lvl_behavior(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCITwoEdgeSepSecondLogicLvlBehavior)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_second_term(self):
        """
        str: Specifies the source terminal of the digital signal that
            stops each measurement.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 6318)
        return val

    @ci_two_edge_sep_second_term.setter
    def ci_two_edge_sep_second_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 6318, val)

    @ci_two_edge_sep_second_term.deleter
    def ci_two_edge_sep_second_term(self):
        cfunc = lib_importer.windll.DAQmxResetCITwoEdgeSepSecondTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_second_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12461)
        return TerminalConfiguration(val)

    @ci_two_edge_sep_second_term_cfg.setter
    def ci_two_edge_sep_second_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12461, val)

    @ci_two_edge_sep_second_term_cfg.deleter
    def ci_two_edge_sep_second_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCITwoEdgeSepSecondTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_two_edge_sep_units(self):
        """
        :class:`nidaqmx.constants.TimeUnits`: Specifies the units to use
            to return two-edge separation measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6316)
        return TimeUnits(val)

    @ci_two_edge_sep_units.setter
    def ci_two_edge_sep_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6316, val)

    @ci_two_edge_sep_units.deleter
    def ci_two_edge_sep_units(self):
        cfunc = lib_importer.windll.DAQmxResetCITwoEdgeSepUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_usb_xfer_req_count(self):
        """
        int: Specifies the maximum number of simultaneous USB transfers
            used to stream data. Modify this value to affect performance
            under different combinations of operating system and device.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 12292)
        return val

    @ci_usb_xfer_req_count.setter
    def ci_usb_xfer_req_count(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 12292, val)

    @ci_usb_xfer_req_count.deleter
    def ci_usb_xfer_req_count(self):
        cfunc = lib_importer.windll.DAQmxResetCIUsbXferReqCount
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_usb_xfer_req_size(self):
        """
        int: Specifies the maximum size of a USB transfer request in
            bytes. Modify this value to affect performance under
            different combinations of operating system and device.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 10898)
        return val

    @ci_usb_xfer_req_size.setter
    def ci_usb_xfer_req_size(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 10898, val)

    @ci_usb_xfer_req_size.deleter
    def ci_usb_xfer_req_size(self):
        cfunc = lib_importer.windll.DAQmxResetCIUsbXferReqSize
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_a_input_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12512)
        return val

    @ci_velocity_a_input_dig_fltr_enable.setter
    def ci_velocity_a_input_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12512, val)

    @ci_velocity_a_input_dig_fltr_enable.deleter
    def ci_velocity_a_input_dig_fltr_enable(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIVelocityEncoderAInputDigFltrEnable)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_a_input_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the digital
            filter recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12513)
        return val

    @ci_velocity_a_input_dig_fltr_min_pulse_width.setter
    def ci_velocity_a_input_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12513, val)

    @ci_velocity_a_input_dig_fltr_min_pulse_width.deleter
    def ci_velocity_a_input_dig_fltr_min_pulse_width(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIVelocityEncoderAInputDigFltrMinPulseWidth)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_a_input_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12515)
        return val

    @ci_velocity_a_input_dig_fltr_timebase_rate.setter
    def ci_velocity_a_input_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12515, val)

    @ci_velocity_a_input_dig_fltr_timebase_rate.deleter
    def ci_velocity_a_input_dig_fltr_timebase_rate(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIVelocityEncoderAInputDigFltrTimebaseRate)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_a_input_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12514)
        return val

    @ci_velocity_a_input_dig_fltr_timebase_src.setter
    def ci_velocity_a_input_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12514, val)

    @ci_velocity_a_input_dig_fltr_timebase_src.deleter
    def ci_velocity_a_input_dig_fltr_timebase_src(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIVelocityEncoderAInputDigFltrTimebaseSrc)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_a_input_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior of the input terminal.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12511)
        return LogicLvlBehavior(val)

    @ci_velocity_a_input_logic_lvl_behavior.setter
    def ci_velocity_a_input_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12511, val)

    @ci_velocity_a_input_logic_lvl_behavior.deleter
    def ci_velocity_a_input_logic_lvl_behavior(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIVelocityEncoderAInputLogicLvlBehavior)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_a_input_term(self):
        """
        str: Specifies the terminal to which signal A is connected.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12509)
        return val

    @ci_velocity_a_input_term.setter
    def ci_velocity_a_input_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12509, val)

    @ci_velocity_a_input_term.deleter
    def ci_velocity_a_input_term(self):
        cfunc = lib_importer.windll.DAQmxResetCIVelocityEncoderAInputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_a_input_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12510)
        return TerminalConfiguration(val)

    @ci_velocity_a_input_term_cfg.setter
    def ci_velocity_a_input_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12510, val)

    @ci_velocity_a_input_term_cfg.deleter
    def ci_velocity_a_input_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCIVelocityEncoderAInputTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_ang_encoder_pulses_per_rev(self):
        """
        int: Specifies the number of pulses the encoder generates per
            revolution. This value is the number of pulses on either
            signal A or signal B, not the total number of pulses on both
            signal A and signal B.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 12505)
        return val

    @ci_velocity_ang_encoder_pulses_per_rev.setter
    def ci_velocity_ang_encoder_pulses_per_rev(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 12505, val)

    @ci_velocity_ang_encoder_pulses_per_rev.deleter
    def ci_velocity_ang_encoder_pulses_per_rev(self):
        cfunc = lib_importer.windll.DAQmxResetCIVelocityAngEncoderPulsesPerRev
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_ang_encoder_units(self):
        """
        :class:`nidaqmx.constants.AngularVelocityUnits`: Specifies the
            units to use to return angular velocity counter
            measurements.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12504)
        return AngularVelocityUnits(val)

    @ci_velocity_ang_encoder_units.setter
    def ci_velocity_ang_encoder_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12504, val)

    @ci_velocity_ang_encoder_units.deleter
    def ci_velocity_ang_encoder_units(self):
        cfunc = lib_importer.windll.DAQmxResetCIVelocityAngEncoderUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_b_input_dig_fltr_enable(self):
        """
        bool: Specifies whether to apply the pulse width filter to the
            signal.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12519)
        return val

    @ci_velocity_b_input_dig_fltr_enable.setter
    def ci_velocity_b_input_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12519, val)

    @ci_velocity_b_input_dig_fltr_enable.deleter
    def ci_velocity_b_input_dig_fltr_enable(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIVelocityEncoderBInputDigFltrEnable)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_b_input_dig_fltr_min_pulse_width(self):
        """
        float: Specifies in seconds the minimum pulse width the digital
            filter recognizes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12520)
        return val

    @ci_velocity_b_input_dig_fltr_min_pulse_width.setter
    def ci_velocity_b_input_dig_fltr_min_pulse_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12520, val)

    @ci_velocity_b_input_dig_fltr_min_pulse_width.deleter
    def ci_velocity_b_input_dig_fltr_min_pulse_width(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIVelocityEncoderBInputDigFltrMinPulseWidth)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_b_input_dig_fltr_timebase_rate(self):
        """
        float: Specifies in hertz the rate of the pulse width filter
            timebase. NI-DAQmx uses this value to compute settings for
            the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12522)
        return val

    @ci_velocity_b_input_dig_fltr_timebase_rate.setter
    def ci_velocity_b_input_dig_fltr_timebase_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12522, val)

    @ci_velocity_b_input_dig_fltr_timebase_rate.deleter
    def ci_velocity_b_input_dig_fltr_timebase_rate(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIVelocityEncoderBInputDigFltrTimebaseRate)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_b_input_dig_fltr_timebase_src(self):
        """
        str: Specifies the input terminal of the signal to use as the
            timebase of the pulse width filter.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12521)
        return val

    @ci_velocity_b_input_dig_fltr_timebase_src.setter
    def ci_velocity_b_input_dig_fltr_timebase_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12521, val)

    @ci_velocity_b_input_dig_fltr_timebase_src.deleter
    def ci_velocity_b_input_dig_fltr_timebase_src(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIVelocityEncoderBInputDigFltrTimebaseSrc)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_b_input_logic_lvl_behavior(self):
        """
        :class:`nidaqmx.constants.LogicLvlBehavior`: Specifies the logic
            level behavior of the input terminal.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12518)
        return LogicLvlBehavior(val)

    @ci_velocity_b_input_logic_lvl_behavior.setter
    def ci_velocity_b_input_logic_lvl_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12518, val)

    @ci_velocity_b_input_logic_lvl_behavior.deleter
    def ci_velocity_b_input_logic_lvl_behavior(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetCIVelocityEncoderBInputLogicLvlBehavior)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_b_input_term(self):
        """
        str: Specifies the terminal to which signal B is connected.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12516)
        return val

    @ci_velocity_b_input_term.setter
    def ci_velocity_b_input_term(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 12516, val)

    @ci_velocity_b_input_term.deleter
    def ci_velocity_b_input_term(self):
        cfunc = lib_importer.windll.DAQmxResetCIVelocityEncoderBInputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_b_input_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            input terminal configuration.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12517)
        return TerminalConfiguration(val)

    @ci_velocity_b_input_term_cfg.setter
    def ci_velocity_b_input_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12517, val)

    @ci_velocity_b_input_term_cfg.deleter
    def ci_velocity_b_input_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetCIVelocityEncoderBInputTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_div(self):
        """
        int: Specifies the value by which to divide the input signal.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 12524)
        return val

    @ci_velocity_div.setter
    def ci_velocity_div(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 12524, val)

    @ci_velocity_div.deleter
    def ci_velocity_div(self):
        cfunc = lib_importer.windll.DAQmxResetCIVelocityDiv
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_encoder_decoding_type(self):
        """
        :class:`nidaqmx.constants.EncoderType`: Specifies how to count
            and interpret the pulses the encoder generates on signal A
            and signal B. X1, X2, and X4 are valid for quadrature
            encoders only. Two Pulse Counting is valid for two-pulse
            encoders only.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12508)
        return EncoderType(val)

    @ci_velocity_encoder_decoding_type.setter
    def ci_velocity_encoder_decoding_type(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12508, val)

    @ci_velocity_encoder_decoding_type.deleter
    def ci_velocity_encoder_decoding_type(self):
        cfunc = lib_importer.windll.DAQmxResetCIVelocityEncoderDecodingType
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_lin_encoder_dist_per_pulse(self):
        """
        float: Specifies the distance to measure for each pulse the
            encoder generates on signal A or signal B. This value is in
            the units you specify in CI.Velocity.LinEncoder.DistUnits.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12507)
        return val

    @ci_velocity_lin_encoder_dist_per_pulse.setter
    def ci_velocity_lin_encoder_dist_per_pulse(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12507, val)

    @ci_velocity_lin_encoder_dist_per_pulse.deleter
    def ci_velocity_lin_encoder_dist_per_pulse(self):
        cfunc = lib_importer.windll.DAQmxResetCIVelocityLinEncoderDistPerPulse
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_lin_encoder_units(self):
        """
        :class:`nidaqmx.constants.VelocityUnits`: Specifies the units to
            use to return linear encoder velocity measurements from the
            channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12506)
        return VelocityUnits(val)

    @ci_velocity_lin_encoder_units.setter
    def ci_velocity_lin_encoder_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12506, val)

    @ci_velocity_lin_encoder_units.deleter
    def ci_velocity_lin_encoder_units(self):
        cfunc = lib_importer.windll.DAQmxResetCIVelocityLinEncoderUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ci_velocity_meas_time(self):
        """
        float: Specifies in seconds the length of time to measure the
            velocity of the signal.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12523)
        return val

    @ci_velocity_meas_time.setter
    def ci_velocity_meas_time(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12523, val)

    @ci_velocity_meas_time.deleter
    def ci_velocity_meas_time(self):
        cfunc = lib_importer.windll.DAQmxResetCIVelocityMeasTime
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

