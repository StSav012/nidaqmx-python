# Do not edit this file; it was automatically generated.

import ctypes
import numpy

from nidaqmx._lib import lib_importer, ctypes_byte_str, c_bool32
from nidaqmx.errors import (
    check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
from nidaqmx.constants import (
    DeassertCondition, DigitalWidthUnits, ExportAction, Level, Polarity,
    Signal)


class ExportSignals:
    """
    Represents the exported signal configurations for a DAQmx task.
    """
    def __init__(self, task_handle, interpreter):
        self._handle = task_handle
        self._interpreter = interpreter

    @property
    def adv_cmplt_event_delay(self):
        """
        float: Specifies the output signal delay in periods of the
            sample clock.
        """


        val = self._interpreter.get_exported_signal_attribute_double(
                self._handle, 5975)
        return val

    @adv_cmplt_event_delay.setter
    def adv_cmplt_event_delay(self, val):
        self._interpreter.set_exported_signal_attribute_double(
                self._handle, 5975, val)

    @adv_cmplt_event_delay.deleter
    def adv_cmplt_event_delay(self):
        cfunc = lib_importer.windll.DAQmxResetExportedAdvCmpltEventDelay
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def adv_cmplt_event_output_term(self):
        """
        str: Specifies the terminal to which to route the Advance
            Complete Event.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 5713)
        return val

    @adv_cmplt_event_output_term.setter
    def adv_cmplt_event_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 5713, val)

    @adv_cmplt_event_output_term.deleter
    def adv_cmplt_event_output_term(self):
        cfunc = lib_importer.windll.DAQmxResetExportedAdvCmpltEventOutputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def adv_cmplt_event_pulse_polarity(self):
        """
        :class:`nidaqmx.constants.Polarity`: Specifies the polarity of
            the exported Advance Complete Event.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 5714)
        return Polarity(val)

    @adv_cmplt_event_pulse_polarity.setter
    def adv_cmplt_event_pulse_polarity(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 5714, val)

    @adv_cmplt_event_pulse_polarity.deleter
    def adv_cmplt_event_pulse_polarity(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedAdvCmpltEventPulsePolarity)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def adv_cmplt_event_pulse_width(self):
        """
        float: Specifies the width of the exported Advance Complete
            Event pulse.
        """


        val = self._interpreter.get_exported_signal_attribute_double(
                self._handle, 5716)
        return val

    @adv_cmplt_event_pulse_width.setter
    def adv_cmplt_event_pulse_width(self, val):
        self._interpreter.set_exported_signal_attribute_double(
                self._handle, 5716, val)

    @adv_cmplt_event_pulse_width.deleter
    def adv_cmplt_event_pulse_width(self):
        cfunc = lib_importer.windll.DAQmxResetExportedAdvCmpltEventPulseWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def adv_trig_output_term(self):
        """
        str: Specifies the terminal to which to route the Advance
            Trigger.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 5701)
        return val

    @adv_trig_output_term.setter
    def adv_trig_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 5701, val)

    @adv_trig_output_term.deleter
    def adv_trig_output_term(self):
        cfunc = lib_importer.windll.DAQmxResetExportedAdvTrigOutputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def adv_trig_pulse_polarity(self):
        """
        :class:`nidaqmx.constants.Polarity`: Indicates the polarity of
            the exported Advance Trigger.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 5702)
        return Polarity(val)

    @property
    def adv_trig_pulse_width(self):
        """
        float: Specifies the width of an exported Advance Trigger pulse.
            Specify this value in the units you specify with
            **adv_trig_pulse_width_units**.
        """


        val = self._interpreter.get_exported_signal_attribute_double(
                self._handle, 5704)
        return val

    @adv_trig_pulse_width.setter
    def adv_trig_pulse_width(self, val):
        self._interpreter.set_exported_signal_attribute_double(
                self._handle, 5704, val)

    @adv_trig_pulse_width.deleter
    def adv_trig_pulse_width(self):
        cfunc = lib_importer.windll.DAQmxResetExportedAdvTrigPulseWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def adv_trig_pulse_width_units(self):
        """
        :class:`nidaqmx.constants.DigitalWidthUnits`: Specifies the
            units of **adv_trig_pulse_width**.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 5703)
        return DigitalWidthUnits(val)

    @adv_trig_pulse_width_units.setter
    def adv_trig_pulse_width_units(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 5703, val)

    @adv_trig_pulse_width_units.deleter
    def adv_trig_pulse_width_units(self):
        cfunc = lib_importer.windll.DAQmxResetExportedAdvTrigPulseWidthUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def ai_conv_clk_output_term(self):
        """
        str: Specifies the terminal to which to route the AI Convert
            Clock.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 5767)
        return val

    @ai_conv_clk_output_term.setter
    def ai_conv_clk_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 5767, val)

    @ai_conv_clk_output_term.deleter
    def ai_conv_clk_output_term(self):
        cfunc = lib_importer.windll.DAQmxResetExportedAIConvClkOutputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def ai_conv_clk_pulse_polarity(self):
        """
        :class:`nidaqmx.constants.Polarity`: Indicates the polarity of
            the exported AI Convert Clock. The polarity is fixed and
            independent of the active edge of the source of the AI
            Convert Clock.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 5768)
        return Polarity(val)

    @property
    def ai_hold_cmplt_event_output_term(self):
        """
        str: Specifies the terminal to which to route the AI Hold
            Complete Event.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 6381)
        return val

    @ai_hold_cmplt_event_output_term.setter
    def ai_hold_cmplt_event_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 6381, val)

    @ai_hold_cmplt_event_output_term.deleter
    def ai_hold_cmplt_event_output_term(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedAIHoldCmpltEventOutputTerm)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def ai_hold_cmplt_event_pulse_polarity(self):
        """
        :class:`nidaqmx.constants.Polarity`: Specifies the polarity of
            an exported AI Hold Complete Event pulse.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 6382)
        return Polarity(val)

    @ai_hold_cmplt_event_pulse_polarity.setter
    def ai_hold_cmplt_event_pulse_polarity(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 6382, val)

    @ai_hold_cmplt_event_pulse_polarity.deleter
    def ai_hold_cmplt_event_pulse_polarity(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedAIHoldCmpltEventPulsePolarity)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def change_detect_event_output_term(self):
        """
        str: Specifies the terminal to which to route the Change
            Detection Event.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 8599)
        return val

    @change_detect_event_output_term.setter
    def change_detect_event_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 8599, val)

    @change_detect_event_output_term.deleter
    def change_detect_event_output_term(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedChangeDetectEventOutputTerm)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def change_detect_event_pulse_polarity(self):
        """
        :class:`nidaqmx.constants.Polarity`: Specifies the polarity of
            an exported Change Detection Event pulse.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 8963)
        return Polarity(val)

    @change_detect_event_pulse_polarity.setter
    def change_detect_event_pulse_polarity(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 8963, val)

    @change_detect_event_pulse_polarity.deleter
    def change_detect_event_pulse_polarity(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedChangeDetectEventPulsePolarity)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def ctr_out_event_output_behavior(self):
        """
        :class:`nidaqmx.constants.ExportAction`: Specifies whether the
            exported Counter Output Event pulses or changes from one
            state to the other when the counter reaches terminal count.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 5967)
        return ExportAction(val)

    @ctr_out_event_output_behavior.setter
    def ctr_out_event_output_behavior(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 5967, val)

    @ctr_out_event_output_behavior.deleter
    def ctr_out_event_output_behavior(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedCtrOutEventOutputBehavior)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def ctr_out_event_output_term(self):
        """
        str: Specifies the terminal to which to route the Counter Output
            Event.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 5911)
        return val

    @ctr_out_event_output_term.setter
    def ctr_out_event_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 5911, val)

    @ctr_out_event_output_term.deleter
    def ctr_out_event_output_term(self):
        cfunc = lib_importer.windll.DAQmxResetExportedCtrOutEventOutputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def ctr_out_event_pulse_polarity(self):
        """
        :class:`nidaqmx.constants.Polarity`: Specifies the polarity of
            the pulses at the output terminal of the counter when
            **ctr_out_event_output_behavior** is
            **ExportActions2.PULSE**. NI-DAQmx ignores this property if
            **ctr_out_event_output_behavior** is
            **ExportActions2.TOGGLE**.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 5912)
        return Polarity(val)

    @ctr_out_event_pulse_polarity.setter
    def ctr_out_event_pulse_polarity(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 5912, val)

    @ctr_out_event_pulse_polarity.deleter
    def ctr_out_event_pulse_polarity(self):
        cfunc = lib_importer.windll.DAQmxResetExportedCtrOutEventPulsePolarity
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def ctr_out_event_toggle_idle_state(self):
        """
        :class:`nidaqmx.constants.Level`: Specifies the initial state of
            the output terminal of the counter when
            **ctr_out_event_output_behavior** is
            **ExportActions2.TOGGLE**. The terminal enters this state
            when NI-DAQmx commits the task.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 6250)
        return Level(val)

    @ctr_out_event_toggle_idle_state.setter
    def ctr_out_event_toggle_idle_state(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 6250, val)

    @ctr_out_event_toggle_idle_state.deleter
    def ctr_out_event_toggle_idle_state(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedCtrOutEventToggleIdleState)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def data_active_event_lvl_active_lvl(self):
        """
        :class:`nidaqmx.constants.Polarity`: Specifies the polarity of
            the exported Data Active Event.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 5684)
        return Polarity(val)

    @data_active_event_lvl_active_lvl.setter
    def data_active_event_lvl_active_lvl(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 5684, val)

    @data_active_event_lvl_active_lvl.deleter
    def data_active_event_lvl_active_lvl(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedDataActiveEventLvlActiveLvl)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def data_active_event_output_term(self):
        """
        str: Specifies the terminal to which to export the Data Active
            Event.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 5683)
        return val

    @data_active_event_output_term.setter
    def data_active_event_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 5683, val)

    @data_active_event_output_term.deleter
    def data_active_event_output_term(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedDataActiveEventOutputTerm)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def divided_samp_clk_timebase_output_term(self):
        """
        str: Specifies the terminal to which to route the Divided Sample
            Clock Timebase.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 8609)
        return val

    @divided_samp_clk_timebase_output_term.setter
    def divided_samp_clk_timebase_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 8609, val)

    @divided_samp_clk_timebase_output_term.deleter
    def divided_samp_clk_timebase_output_term(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedDividedSampClkTimebaseOutputTerm)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def exported_10_mhz_ref_clk_output_term(self):
        """
        str: Specifies the terminal to which to route the 10MHz Clock.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 8814)
        return val

    @exported_10_mhz_ref_clk_output_term.setter
    def exported_10_mhz_ref_clk_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 8814, val)

    @exported_10_mhz_ref_clk_output_term.deleter
    def exported_10_mhz_ref_clk_output_term(self):
        cfunc = lib_importer.windll.DAQmxResetExported10MHzRefClkOutputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def exported_20_mhz_timebase_output_term(self):
        """
        str: Specifies the terminal to which to route the 20MHz
            Timebase.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 5719)
        return val

    @exported_20_mhz_timebase_output_term.setter
    def exported_20_mhz_timebase_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 5719, val)

    @exported_20_mhz_timebase_output_term.deleter
    def exported_20_mhz_timebase_output_term(self):
        cfunc = lib_importer.windll.DAQmxResetExported20MHzTimebaseOutputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def hshk_event_delay(self):
        """
        float: Specifies the number of seconds to delay after the
            Handshake Trigger deasserts before asserting the Handshake
            Event.
        """


        val = self._interpreter.get_exported_signal_attribute_double(
                self._handle, 8892)
        return val

    @hshk_event_delay.setter
    def hshk_event_delay(self, val):
        self._interpreter.set_exported_signal_attribute_double(
                self._handle, 8892, val)

    @hshk_event_delay.deleter
    def hshk_event_delay(self):
        cfunc = lib_importer.windll.DAQmxResetExportedHshkEventDelay
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def hshk_event_interlocked_assert_on_start(self):
        """
        bool: Specifies to assert the Handshake Event when the task
            starts if **hshk_event_output_behavior** is
            **ExportActions5.INTERLOCKED**.
        """


        val = self._interpreter.get_exported_signal_attribute_bool(
                self._handle, 8894)
        return val

    @hshk_event_interlocked_assert_on_start.setter
    def hshk_event_interlocked_assert_on_start(self, val):
        self._interpreter.set_exported_signal_attribute_bool(
                self._handle, 8894, val)

    @hshk_event_interlocked_assert_on_start.deleter
    def hshk_event_interlocked_assert_on_start(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedHshkEventInterlockedAssertOnStart)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def hshk_event_interlocked_asserted_lvl(self):
        """
        :class:`nidaqmx.constants.Level`: Specifies the asserted level
            of the exported Handshake Event if
            **hshk_event_output_behavior** is
            **ExportActions5.INTERLOCKED**.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 8893)
        return Level(val)

    @hshk_event_interlocked_asserted_lvl.setter
    def hshk_event_interlocked_asserted_lvl(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 8893, val)

    @hshk_event_interlocked_asserted_lvl.deleter
    def hshk_event_interlocked_asserted_lvl(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedHshkEventInterlockedAssertedLvl)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def hshk_event_interlocked_deassert_delay(self):
        """
        float: Specifies in seconds the amount of time to wait after the
            Handshake Trigger asserts before deasserting the Handshake
            Event if **hshk_event_output_behavior** is
            **ExportActions5.INTERLOCKED**.
        """


        val = self._interpreter.get_exported_signal_attribute_double(
                self._handle, 8895)
        return val

    @hshk_event_interlocked_deassert_delay.setter
    def hshk_event_interlocked_deassert_delay(self, val):
        self._interpreter.set_exported_signal_attribute_double(
                self._handle, 8895, val)

    @hshk_event_interlocked_deassert_delay.deleter
    def hshk_event_interlocked_deassert_delay(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedHshkEventInterlockedDeassertDelay)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def hshk_event_output_behavior(self):
        """
        :class:`nidaqmx.constants.ExportAction`: Specifies the output
            behavior of the Handshake Event.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 8891)
        return ExportAction(val)

    @hshk_event_output_behavior.setter
    def hshk_event_output_behavior(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 8891, val)

    @hshk_event_output_behavior.deleter
    def hshk_event_output_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetExportedHshkEventOutputBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def hshk_event_output_term(self):
        """
        str: Specifies the terminal to which to route the Handshake
            Event.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 8890)
        return val

    @hshk_event_output_term.setter
    def hshk_event_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 8890, val)

    @hshk_event_output_term.deleter
    def hshk_event_output_term(self):
        cfunc = lib_importer.windll.DAQmxResetExportedHshkEventOutputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def hshk_event_pulse_polarity(self):
        """
        :class:`nidaqmx.constants.Polarity`: Specifies the polarity of
            the exported Handshake Event if
            **hshk_event_output_behavior** is **ExportActions5.PULSE**.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 8896)
        return Polarity(val)

    @hshk_event_pulse_polarity.setter
    def hshk_event_pulse_polarity(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 8896, val)

    @hshk_event_pulse_polarity.deleter
    def hshk_event_pulse_polarity(self):
        cfunc = lib_importer.windll.DAQmxResetExportedHshkEventPulsePolarity
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def hshk_event_pulse_width(self):
        """
        float: Specifies in seconds the pulse width of the exported
            Handshake Event if **hshk_event_output_behavior** is
            **ExportActions5.PULSE**.
        """


        val = self._interpreter.get_exported_signal_attribute_double(
                self._handle, 8897)
        return val

    @hshk_event_pulse_width.setter
    def hshk_event_pulse_width(self, val):
        self._interpreter.set_exported_signal_attribute_double(
                self._handle, 8897, val)

    @hshk_event_pulse_width.deleter
    def hshk_event_pulse_width(self):
        cfunc = lib_importer.windll.DAQmxResetExportedHshkEventPulseWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def pause_trig_lvl_active_lvl(self):
        """
        :class:`nidaqmx.constants.Polarity`: Specifies the active level
            of the exported Pause Trigger.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 5654)
        return Polarity(val)

    @pause_trig_lvl_active_lvl.setter
    def pause_trig_lvl_active_lvl(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 5654, val)

    @pause_trig_lvl_active_lvl.deleter
    def pause_trig_lvl_active_lvl(self):
        cfunc = lib_importer.windll.DAQmxResetExportedPauseTrigLvlActiveLvl
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def pause_trig_output_term(self):
        """
        str: Specifies the terminal to which to route the Pause Trigger.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 5653)
        return val

    @pause_trig_output_term.setter
    def pause_trig_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 5653, val)

    @pause_trig_output_term.deleter
    def pause_trig_output_term(self):
        cfunc = lib_importer.windll.DAQmxResetExportedPauseTrigOutputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def rdy_for_start_event_lvl_active_lvl(self):
        """
        :class:`nidaqmx.constants.Polarity`: Specifies the polarity of
            the exported Ready for Start Event.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 5969)
        return Polarity(val)

    @rdy_for_start_event_lvl_active_lvl.setter
    def rdy_for_start_event_lvl_active_lvl(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 5969, val)

    @rdy_for_start_event_lvl_active_lvl.deleter
    def rdy_for_start_event_lvl_active_lvl(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedRdyForStartEventLvlActiveLvl)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def rdy_for_start_event_output_term(self):
        """
        str: Specifies the terminal to which to route the Ready for
            Start Event.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 5641)
        return val

    @rdy_for_start_event_output_term.setter
    def rdy_for_start_event_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 5641, val)

    @rdy_for_start_event_output_term.deleter
    def rdy_for_start_event_output_term(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedRdyForStartEventOutputTerm)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def rdy_for_xfer_event_deassert_cond(self):
        """
        :class:`nidaqmx.constants.DeassertCondition`: Specifies when the
            ready for transfer event deasserts.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 10595)
        return DeassertCondition(val)

    @rdy_for_xfer_event_deassert_cond.setter
    def rdy_for_xfer_event_deassert_cond(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 10595, val)

    @rdy_for_xfer_event_deassert_cond.deleter
    def rdy_for_xfer_event_deassert_cond(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedRdyForXferEventDeassertCond)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def rdy_for_xfer_event_deassert_cond_custom_threshold(self):
        """
        int: Specifies in samples the threshold below which the Ready
            for Transfer Event deasserts. This threshold is an amount of
            space available in the onboard memory of the device.
            **rdy_for_xfer_event_deassert_cond** must be
            **DeassertCondition.ONBOARD_MEMORY_CUSTOM_THRESHOLD** to use
            a custom threshold.
        """


        val = self._interpreter.get_exported_signal_attribute_uint32(
                self._handle, 10596)
        return val

    @rdy_for_xfer_event_deassert_cond_custom_threshold.setter
    def rdy_for_xfer_event_deassert_cond_custom_threshold(self, val):
        self._interpreter.set_exported_signal_attribute_uint32(
                self._handle, 10596, val)

    @rdy_for_xfer_event_deassert_cond_custom_threshold.deleter
    def rdy_for_xfer_event_deassert_cond_custom_threshold(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedRdyForXferEventDeassertCondCustomThreshold)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def rdy_for_xfer_event_lvl_active_lvl(self):
        """
        :class:`nidaqmx.constants.Polarity`: Specifies the active level
            of the exported Ready for Transfer Event.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 8886)
        return Polarity(val)

    @rdy_for_xfer_event_lvl_active_lvl.setter
    def rdy_for_xfer_event_lvl_active_lvl(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 8886, val)

    @rdy_for_xfer_event_lvl_active_lvl.deleter
    def rdy_for_xfer_event_lvl_active_lvl(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedRdyForXferEventLvlActiveLvl)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def rdy_for_xfer_event_output_term(self):
        """
        str: Specifies the terminal to which to route the Ready for
            Transfer Event.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 8885)
        return val

    @rdy_for_xfer_event_output_term.setter
    def rdy_for_xfer_event_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 8885, val)

    @rdy_for_xfer_event_output_term.deleter
    def rdy_for_xfer_event_output_term(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedRdyForXferEventOutputTerm)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def ref_trig_output_term(self):
        """
        str: Specifies the terminal to which to route the Reference
            Trigger.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 1424)
        return val

    @ref_trig_output_term.setter
    def ref_trig_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 1424, val)

    @ref_trig_output_term.deleter
    def ref_trig_output_term(self):
        cfunc = lib_importer.windll.DAQmxResetExportedRefTrigOutputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def ref_trig_pulse_polarity(self):
        """
        :class:`nidaqmx.constants.Polarity`: Specifies the polarity of
            the exported Reference Trigger.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 1425)
        return Polarity(val)

    @ref_trig_pulse_polarity.setter
    def ref_trig_pulse_polarity(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 1425, val)

    @ref_trig_pulse_polarity.deleter
    def ref_trig_pulse_polarity(self):
        cfunc = lib_importer.windll.DAQmxResetExportedRefTrigPulsePolarity
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def samp_clk_delay_offset(self):
        """
        float: Specifies in seconds the amount of time to offset the
            exported Sample clock.  Refer to timing diagrams for
            generation applications in the device documentation for more
            information about this value.
        """


        val = self._interpreter.get_exported_signal_attribute_double(
                self._handle, 8644)
        return val

    @samp_clk_delay_offset.setter
    def samp_clk_delay_offset(self, val):
        self._interpreter.set_exported_signal_attribute_double(
                self._handle, 8644, val)

    @samp_clk_delay_offset.deleter
    def samp_clk_delay_offset(self):
        cfunc = lib_importer.windll.DAQmxResetExportedSampClkDelayOffset
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def samp_clk_output_behavior(self):
        """
        :class:`nidaqmx.constants.ExportAction`: Specifies whether the
            exported Sample Clock issues a pulse at the beginning of a
            sample or changes to a high state for the duration of the
            sample.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 6251)
        return ExportAction(val)

    @samp_clk_output_behavior.setter
    def samp_clk_output_behavior(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 6251, val)

    @samp_clk_output_behavior.deleter
    def samp_clk_output_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetExportedSampClkOutputBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def samp_clk_output_term(self):
        """
        str: Specifies the terminal to which to route the Sample Clock.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 5731)
        return val

    @samp_clk_output_term.setter
    def samp_clk_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 5731, val)

    @samp_clk_output_term.deleter
    def samp_clk_output_term(self):
        cfunc = lib_importer.windll.DAQmxResetExportedSampClkOutputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def samp_clk_pulse_polarity(self):
        """
        :class:`nidaqmx.constants.Polarity`: Specifies the polarity of
            the exported Sample Clock if **samp_clk_output_behavior** is
            **ExportActions3.PULSE**.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 5732)
        return Polarity(val)

    @samp_clk_pulse_polarity.setter
    def samp_clk_pulse_polarity(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 5732, val)

    @samp_clk_pulse_polarity.deleter
    def samp_clk_pulse_polarity(self):
        cfunc = lib_importer.windll.DAQmxResetExportedSampClkPulsePolarity
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def samp_clk_timebase_output_term(self):
        """
        str: Specifies the terminal to which to route the Sample Clock
            Timebase.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 6393)
        return val

    @samp_clk_timebase_output_term.setter
    def samp_clk_timebase_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 6393, val)

    @samp_clk_timebase_output_term.deleter
    def samp_clk_timebase_output_term(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedSampClkTimebaseOutputTerm)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def start_trig_output_term(self):
        """
        str: Specifies the terminal to which to route the Start Trigger.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 1412)
        return val

    @start_trig_output_term.setter
    def start_trig_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 1412, val)

    @start_trig_output_term.deleter
    def start_trig_output_term(self):
        cfunc = lib_importer.windll.DAQmxResetExportedStartTrigOutputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def start_trig_pulse_polarity(self):
        """
        :class:`nidaqmx.constants.Polarity`: Specifies the polarity of
            the exported Start Trigger.
        """


        val = self._interpreter.get_exported_signal_attribute_int32(
                self._handle, 1413)
        return Polarity(val)

    @start_trig_pulse_polarity.setter
    def start_trig_pulse_polarity(self, val):
        val = val.value
        self._interpreter.set_exported_signal_attribute_int32(
                self._handle, 1413, val)

    @start_trig_pulse_polarity.deleter
    def start_trig_pulse_polarity(self):
        cfunc = lib_importer.windll.DAQmxResetExportedStartTrigPulsePolarity
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def sync_pulse_event_output_term(self):
        """
        str: Specifies the terminal to which to route the
            Synchronization Pulse Event.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 8764)
        return val

    @sync_pulse_event_output_term.setter
    def sync_pulse_event_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 8764, val)

    @sync_pulse_event_output_term.deleter
    def sync_pulse_event_output_term(self):
        cfunc = lib_importer.windll.DAQmxResetExportedSyncPulseEventOutputTerm
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    @property
    def watchdog_expired_event_output_term(self):
        """
        str: Specifies the terminal  to which to route the Watchdog
            Timer Expired Event.
        """


        val = self._interpreter.get_exported_signal_attribute_string(
                self._handle, 8618)
        return val

    @watchdog_expired_event_output_term.setter
    def watchdog_expired_event_output_term(self, val):
        self._interpreter.set_exported_signal_attribute_string(
                self._handle, 8618, val)

    @watchdog_expired_event_output_term.deleter
    def watchdog_expired_event_output_term(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetExportedWatchdogExpiredEventOutputTerm)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle]

        error_code = cfunc(
            self._handle)
        check_for_error(error_code)

    def export_signal(self, signal_id, output_terminal):
        """
        Routes a control signal to the terminal you specify. The output
        terminal can reside on the device that generates the control
        signal or on a different device. You can use this function to
        share clocks and triggers among multiple tasks and devices. The
        routes this function creates are task-based routes.

        Args:
            signal_id (nidaqmx.constants.Signal): Is the name of the
                trigger, clock, or event to export.
            output_terminal (str): Is the destination of the exported
                signal. A DAQmx terminal constant lists all terminals on
                installed devices. You can also specify a string
                containing a comma-delimited list of terminal names.
        """
        cfunc = lib_importer.windll.DAQmxExportSignal
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes.c_int,
                        ctypes_byte_str]

        error_code = cfunc(
            self._handle, signal_id.value, output_terminal)
        check_for_error(error_code)

